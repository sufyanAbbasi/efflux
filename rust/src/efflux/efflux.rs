// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `efflux.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:efflux.WorkSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.WorkSocketData.work_type)
    pub work_type: i32,
    // @@protoc_insertion_point(field:efflux.WorkSocketData.result)
    pub result: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.WorkSocketData.status)
    pub status: i32,
    // @@protoc_insertion_point(field:efflux.WorkSocketData.diffusion)
    pub diffusion: ::protobuf::MessageField<DiffusionSocketData>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.WorkSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkSocketData {
    fn default() -> &'a WorkSocketData {
        <WorkSocketData as ::protobuf::Message>::default_instance()
    }
}

impl WorkSocketData {
    pub fn new() -> WorkSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_type",
            |m: &WorkSocketData| { &m.work_type },
            |m: &mut WorkSocketData| { &mut m.work_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &WorkSocketData| { &m.result },
            |m: &mut WorkSocketData| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &WorkSocketData| { &m.status },
            |m: &mut WorkSocketData| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DiffusionSocketData>(
            "diffusion",
            |m: &WorkSocketData| { &m.diffusion },
            |m: &mut WorkSocketData| { &mut m.diffusion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkSocketData>(
            "WorkSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkSocketData {
    const NAME: &'static str = "WorkSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.work_type = is.read_int32()?;
                },
                18 => {
                    self.result = is.read_string()?;
                },
                24 => {
                    self.status = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.diffusion)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.work_type != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.work_type);
        }
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.result);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.status);
        }
        if let Some(v) = self.diffusion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.work_type != 0 {
            os.write_int32(1, self.work_type)?;
        }
        if !self.result.is_empty() {
            os.write_string(2, &self.result)?;
        }
        if self.status != 0 {
            os.write_int32(3, self.status)?;
        }
        if let Some(v) = self.diffusion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkSocketData {
        WorkSocketData::new()
    }

    fn clear(&mut self) {
        self.work_type = 0;
        self.result.clear();
        self.status = 0;
        self.diffusion.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkSocketData {
        static instance: WorkSocketData = WorkSocketData {
            work_type: 0,
            result: ::std::string::String::new(),
            status: 0,
            diffusion: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.ResourceBlobSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceBlobSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.ResourceBlobSocketData.o2)
    pub o2: i32,
    // @@protoc_insertion_point(field:efflux.ResourceBlobSocketData.glucose)
    pub glucose: i32,
    // @@protoc_insertion_point(field:efflux.ResourceBlobSocketData.vitamins)
    pub vitamins: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.ResourceBlobSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceBlobSocketData {
    fn default() -> &'a ResourceBlobSocketData {
        <ResourceBlobSocketData as ::protobuf::Message>::default_instance()
    }
}

impl ResourceBlobSocketData {
    pub fn new() -> ResourceBlobSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "o2",
            |m: &ResourceBlobSocketData| { &m.o2 },
            |m: &mut ResourceBlobSocketData| { &mut m.o2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "glucose",
            |m: &ResourceBlobSocketData| { &m.glucose },
            |m: &mut ResourceBlobSocketData| { &mut m.glucose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vitamins",
            |m: &ResourceBlobSocketData| { &m.vitamins },
            |m: &mut ResourceBlobSocketData| { &mut m.vitamins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceBlobSocketData>(
            "ResourceBlobSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceBlobSocketData {
    const NAME: &'static str = "ResourceBlobSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.o2 = is.read_int32()?;
                },
                16 => {
                    self.glucose = is.read_int32()?;
                },
                24 => {
                    self.vitamins = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.o2 != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.o2);
        }
        if self.glucose != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.glucose);
        }
        if self.vitamins != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.vitamins);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.o2 != 0 {
            os.write_int32(1, self.o2)?;
        }
        if self.glucose != 0 {
            os.write_int32(2, self.glucose)?;
        }
        if self.vitamins != 0 {
            os.write_int32(3, self.vitamins)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceBlobSocketData {
        ResourceBlobSocketData::new()
    }

    fn clear(&mut self) {
        self.o2 = 0;
        self.glucose = 0;
        self.vitamins = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceBlobSocketData {
        static instance: ResourceBlobSocketData = ResourceBlobSocketData {
            o2: 0,
            glucose: 0,
            vitamins: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceBlobSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceBlobSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceBlobSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceBlobSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.WasteBlobSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WasteBlobSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.WasteBlobSocketData.c_o2)
    pub c_o2: i32,
    // @@protoc_insertion_point(field:efflux.WasteBlobSocketData.creatinine)
    pub creatinine: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.WasteBlobSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WasteBlobSocketData {
    fn default() -> &'a WasteBlobSocketData {
        <WasteBlobSocketData as ::protobuf::Message>::default_instance()
    }
}

impl WasteBlobSocketData {
    pub fn new() -> WasteBlobSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c_o2",
            |m: &WasteBlobSocketData| { &m.c_o2 },
            |m: &mut WasteBlobSocketData| { &mut m.c_o2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creatinine",
            |m: &WasteBlobSocketData| { &m.creatinine },
            |m: &mut WasteBlobSocketData| { &mut m.creatinine },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WasteBlobSocketData>(
            "WasteBlobSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WasteBlobSocketData {
    const NAME: &'static str = "WasteBlobSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.c_o2 = is.read_int32()?;
                },
                16 => {
                    self.creatinine = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.c_o2 != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.c_o2);
        }
        if self.creatinine != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.creatinine);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.c_o2 != 0 {
            os.write_int32(1, self.c_o2)?;
        }
        if self.creatinine != 0 {
            os.write_int32(2, self.creatinine)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WasteBlobSocketData {
        WasteBlobSocketData::new()
    }

    fn clear(&mut self) {
        self.c_o2 = 0;
        self.creatinine = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WasteBlobSocketData {
        static instance: WasteBlobSocketData = WasteBlobSocketData {
            c_o2: 0,
            creatinine: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WasteBlobSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WasteBlobSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WasteBlobSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WasteBlobSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.HormoneBlobSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HormoneBlobSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.HormoneBlobSocketData.granulocyte_colony_stimulating_factor)
    pub granulocyte_colony_stimulating_factor: i32,
    // @@protoc_insertion_point(field:efflux.HormoneBlobSocketData.macrophage_colony_stimulating_factor)
    pub macrophage_colony_stimulating_factor: i32,
    // @@protoc_insertion_point(field:efflux.HormoneBlobSocketData.interleukin3)
    pub interleukin3: i32,
    // @@protoc_insertion_point(field:efflux.HormoneBlobSocketData.interleukin2)
    pub interleukin2: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.HormoneBlobSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HormoneBlobSocketData {
    fn default() -> &'a HormoneBlobSocketData {
        <HormoneBlobSocketData as ::protobuf::Message>::default_instance()
    }
}

impl HormoneBlobSocketData {
    pub fn new() -> HormoneBlobSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "granulocyte_colony_stimulating_factor",
            |m: &HormoneBlobSocketData| { &m.granulocyte_colony_stimulating_factor },
            |m: &mut HormoneBlobSocketData| { &mut m.granulocyte_colony_stimulating_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macrophage_colony_stimulating_factor",
            |m: &HormoneBlobSocketData| { &m.macrophage_colony_stimulating_factor },
            |m: &mut HormoneBlobSocketData| { &mut m.macrophage_colony_stimulating_factor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interleukin3",
            |m: &HormoneBlobSocketData| { &m.interleukin3 },
            |m: &mut HormoneBlobSocketData| { &mut m.interleukin3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interleukin2",
            |m: &HormoneBlobSocketData| { &m.interleukin2 },
            |m: &mut HormoneBlobSocketData| { &mut m.interleukin2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HormoneBlobSocketData>(
            "HormoneBlobSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HormoneBlobSocketData {
    const NAME: &'static str = "HormoneBlobSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.granulocyte_colony_stimulating_factor = is.read_int32()?;
                },
                16 => {
                    self.macrophage_colony_stimulating_factor = is.read_int32()?;
                },
                24 => {
                    self.interleukin3 = is.read_int32()?;
                },
                32 => {
                    self.interleukin2 = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.granulocyte_colony_stimulating_factor != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.granulocyte_colony_stimulating_factor);
        }
        if self.macrophage_colony_stimulating_factor != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.macrophage_colony_stimulating_factor);
        }
        if self.interleukin3 != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.interleukin3);
        }
        if self.interleukin2 != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.interleukin2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.granulocyte_colony_stimulating_factor != 0 {
            os.write_int32(1, self.granulocyte_colony_stimulating_factor)?;
        }
        if self.macrophage_colony_stimulating_factor != 0 {
            os.write_int32(2, self.macrophage_colony_stimulating_factor)?;
        }
        if self.interleukin3 != 0 {
            os.write_int32(3, self.interleukin3)?;
        }
        if self.interleukin2 != 0 {
            os.write_int32(4, self.interleukin2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HormoneBlobSocketData {
        HormoneBlobSocketData::new()
    }

    fn clear(&mut self) {
        self.granulocyte_colony_stimulating_factor = 0;
        self.macrophage_colony_stimulating_factor = 0;
        self.interleukin3 = 0;
        self.interleukin2 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HormoneBlobSocketData {
        static instance: HormoneBlobSocketData = HormoneBlobSocketData {
            granulocyte_colony_stimulating_factor: 0,
            macrophage_colony_stimulating_factor: 0,
            interleukin3: 0,
            interleukin2: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HormoneBlobSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HormoneBlobSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HormoneBlobSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HormoneBlobSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.AntigenBlobSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AntigenBlobSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.AntigenBlobSocketData.antibody_proteins)
    pub antibody_proteins: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:efflux.AntigenBlobSocketData.antibody_concentrations)
    pub antibody_concentrations: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.AntigenBlobSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AntigenBlobSocketData {
    fn default() -> &'a AntigenBlobSocketData {
        <AntigenBlobSocketData as ::protobuf::Message>::default_instance()
    }
}

impl AntigenBlobSocketData {
    pub fn new() -> AntigenBlobSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "antibody_proteins",
            |m: &AntigenBlobSocketData| { &m.antibody_proteins },
            |m: &mut AntigenBlobSocketData| { &mut m.antibody_proteins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "antibody_concentrations",
            |m: &AntigenBlobSocketData| { &m.antibody_concentrations },
            |m: &mut AntigenBlobSocketData| { &mut m.antibody_concentrations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AntigenBlobSocketData>(
            "AntigenBlobSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AntigenBlobSocketData {
    const NAME: &'static str = "AntigenBlobSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.antibody_proteins)?;
                },
                8 => {
                    self.antibody_proteins.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int64_into(&mut self.antibody_concentrations)?;
                },
                16 => {
                    self.antibody_concentrations.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.antibody_proteins);
        my_size += ::protobuf::rt::vec_packed_int64_size(2, &self.antibody_concentrations);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_int32(1, &self.antibody_proteins)?;
        os.write_repeated_packed_int64(2, &self.antibody_concentrations)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AntigenBlobSocketData {
        AntigenBlobSocketData::new()
    }

    fn clear(&mut self) {
        self.antibody_proteins.clear();
        self.antibody_concentrations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AntigenBlobSocketData {
        static instance: AntigenBlobSocketData = AntigenBlobSocketData {
            antibody_proteins: ::std::vec::Vec::new(),
            antibody_concentrations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AntigenBlobSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AntigenBlobSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AntigenBlobSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AntigenBlobSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.DiffusionSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DiffusionSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.DiffusionSocketData.resources)
    pub resources: ::protobuf::MessageField<ResourceBlobSocketData>,
    // @@protoc_insertion_point(field:efflux.DiffusionSocketData.waste)
    pub waste: ::protobuf::MessageField<WasteBlobSocketData>,
    // @@protoc_insertion_point(field:efflux.DiffusionSocketData.hormone)
    pub hormone: ::protobuf::MessageField<HormoneBlobSocketData>,
    // @@protoc_insertion_point(field:efflux.DiffusionSocketData.antigen)
    pub antigen: ::protobuf::MessageField<AntigenBlobSocketData>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.DiffusionSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffusionSocketData {
    fn default() -> &'a DiffusionSocketData {
        <DiffusionSocketData as ::protobuf::Message>::default_instance()
    }
}

impl DiffusionSocketData {
    pub fn new() -> DiffusionSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ResourceBlobSocketData>(
            "resources",
            |m: &DiffusionSocketData| { &m.resources },
            |m: &mut DiffusionSocketData| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WasteBlobSocketData>(
            "waste",
            |m: &DiffusionSocketData| { &m.waste },
            |m: &mut DiffusionSocketData| { &mut m.waste },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HormoneBlobSocketData>(
            "hormone",
            |m: &DiffusionSocketData| { &m.hormone },
            |m: &mut DiffusionSocketData| { &mut m.hormone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AntigenBlobSocketData>(
            "antigen",
            |m: &DiffusionSocketData| { &m.antigen },
            |m: &mut DiffusionSocketData| { &mut m.antigen },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffusionSocketData>(
            "DiffusionSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffusionSocketData {
    const NAME: &'static str = "DiffusionSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resources)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.waste)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hormone)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.antigen)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.waste.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hormone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.antigen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resources.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.waste.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.hormone.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.antigen.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffusionSocketData {
        DiffusionSocketData::new()
    }

    fn clear(&mut self) {
        self.resources.clear();
        self.waste.clear();
        self.hormone.clear();
        self.antigen.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffusionSocketData {
        static instance: DiffusionSocketData = DiffusionSocketData {
            resources: ::protobuf::MessageField::none(),
            waste: ::protobuf::MessageField::none(),
            hormone: ::protobuf::MessageField::none(),
            antigen: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffusionSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffusionSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffusionSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffusionSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.WorkStatusSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkStatusSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.work_type)
    pub work_type: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.request_count)
    pub request_count: i32,
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.success_count)
    pub success_count: i32,
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.failure_count)
    pub failure_count: i32,
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.completed_count)
    pub completed_count: i32,
    // @@protoc_insertion_point(field:efflux.WorkStatusSocketData.completed_failure_count)
    pub completed_failure_count: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.WorkStatusSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkStatusSocketData {
    fn default() -> &'a WorkStatusSocketData {
        <WorkStatusSocketData as ::protobuf::Message>::default_instance()
    }
}

impl WorkStatusSocketData {
    pub fn new() -> WorkStatusSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_type",
            |m: &WorkStatusSocketData| { &m.work_type },
            |m: &mut WorkStatusSocketData| { &mut m.work_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_count",
            |m: &WorkStatusSocketData| { &m.request_count },
            |m: &mut WorkStatusSocketData| { &mut m.request_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success_count",
            |m: &WorkStatusSocketData| { &m.success_count },
            |m: &mut WorkStatusSocketData| { &mut m.success_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failure_count",
            |m: &WorkStatusSocketData| { &m.failure_count },
            |m: &mut WorkStatusSocketData| { &mut m.failure_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completed_count",
            |m: &WorkStatusSocketData| { &m.completed_count },
            |m: &mut WorkStatusSocketData| { &mut m.completed_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completed_failure_count",
            |m: &WorkStatusSocketData| { &m.completed_failure_count },
            |m: &mut WorkStatusSocketData| { &mut m.completed_failure_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkStatusSocketData>(
            "WorkStatusSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkStatusSocketData {
    const NAME: &'static str = "WorkStatusSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_type = is.read_string()?;
                },
                16 => {
                    self.request_count = is.read_int32()?;
                },
                24 => {
                    self.success_count = is.read_int32()?;
                },
                32 => {
                    self.failure_count = is.read_int32()?;
                },
                40 => {
                    self.completed_count = is.read_int32()?;
                },
                48 => {
                    self.completed_failure_count = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_type);
        }
        if self.request_count != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.request_count);
        }
        if self.success_count != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.success_count);
        }
        if self.failure_count != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.failure_count);
        }
        if self.completed_count != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.completed_count);
        }
        if self.completed_failure_count != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.completed_failure_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_type.is_empty() {
            os.write_string(1, &self.work_type)?;
        }
        if self.request_count != 0 {
            os.write_int32(2, self.request_count)?;
        }
        if self.success_count != 0 {
            os.write_int32(3, self.success_count)?;
        }
        if self.failure_count != 0 {
            os.write_int32(4, self.failure_count)?;
        }
        if self.completed_count != 0 {
            os.write_int32(5, self.completed_count)?;
        }
        if self.completed_failure_count != 0 {
            os.write_int32(6, self.completed_failure_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkStatusSocketData {
        WorkStatusSocketData::new()
    }

    fn clear(&mut self) {
        self.work_type.clear();
        self.request_count = 0;
        self.success_count = 0;
        self.failure_count = 0;
        self.completed_count = 0;
        self.completed_failure_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkStatusSocketData {
        static instance: WorkStatusSocketData = WorkStatusSocketData {
            work_type: ::std::string::String::new(),
            request_count: 0,
            success_count: 0,
            failure_count: 0,
            completed_count: 0,
            completed_failure_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkStatusSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkStatusSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkStatusSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkStatusSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.MaterialStatusSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MaterialStatusSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.o2)
    pub o2: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.glucose)
    pub glucose: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.vitamin)
    pub vitamin: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.co2)
    pub co2: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.creatinine)
    pub creatinine: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.growth)
    pub growth: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.hunger)
    pub hunger: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.asphyxia)
    pub asphyxia: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.inflammation)
    pub inflammation: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.g_csf)
    pub g_csf: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.m_csf)
    pub m_csf: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.il_3)
    pub il_3: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.il_2)
    pub il_2: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.viral_load)
    pub viral_load: i32,
    // @@protoc_insertion_point(field:efflux.MaterialStatusSocketData.antibody_load)
    pub antibody_load: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.MaterialStatusSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MaterialStatusSocketData {
    fn default() -> &'a MaterialStatusSocketData {
        <MaterialStatusSocketData as ::protobuf::Message>::default_instance()
    }
}

impl MaterialStatusSocketData {
    pub fn new() -> MaterialStatusSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "o2",
            |m: &MaterialStatusSocketData| { &m.o2 },
            |m: &mut MaterialStatusSocketData| { &mut m.o2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "glucose",
            |m: &MaterialStatusSocketData| { &m.glucose },
            |m: &mut MaterialStatusSocketData| { &mut m.glucose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vitamin",
            |m: &MaterialStatusSocketData| { &m.vitamin },
            |m: &mut MaterialStatusSocketData| { &mut m.vitamin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "co2",
            |m: &MaterialStatusSocketData| { &m.co2 },
            |m: &mut MaterialStatusSocketData| { &mut m.co2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creatinine",
            |m: &MaterialStatusSocketData| { &m.creatinine },
            |m: &mut MaterialStatusSocketData| { &mut m.creatinine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "growth",
            |m: &MaterialStatusSocketData| { &m.growth },
            |m: &mut MaterialStatusSocketData| { &mut m.growth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hunger",
            |m: &MaterialStatusSocketData| { &m.hunger },
            |m: &mut MaterialStatusSocketData| { &mut m.hunger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asphyxia",
            |m: &MaterialStatusSocketData| { &m.asphyxia },
            |m: &mut MaterialStatusSocketData| { &mut m.asphyxia },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inflammation",
            |m: &MaterialStatusSocketData| { &m.inflammation },
            |m: &mut MaterialStatusSocketData| { &mut m.inflammation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "g_csf",
            |m: &MaterialStatusSocketData| { &m.g_csf },
            |m: &mut MaterialStatusSocketData| { &mut m.g_csf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "m_csf",
            |m: &MaterialStatusSocketData| { &m.m_csf },
            |m: &mut MaterialStatusSocketData| { &mut m.m_csf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "il_3",
            |m: &MaterialStatusSocketData| { &m.il_3 },
            |m: &mut MaterialStatusSocketData| { &mut m.il_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "il_2",
            |m: &MaterialStatusSocketData| { &m.il_2 },
            |m: &mut MaterialStatusSocketData| { &mut m.il_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "viral_load",
            |m: &MaterialStatusSocketData| { &m.viral_load },
            |m: &mut MaterialStatusSocketData| { &mut m.viral_load },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "antibody_load",
            |m: &MaterialStatusSocketData| { &m.antibody_load },
            |m: &mut MaterialStatusSocketData| { &mut m.antibody_load },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MaterialStatusSocketData>(
            "MaterialStatusSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MaterialStatusSocketData {
    const NAME: &'static str = "MaterialStatusSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.o2 = is.read_int32()?;
                },
                16 => {
                    self.glucose = is.read_int32()?;
                },
                24 => {
                    self.vitamin = is.read_int32()?;
                },
                32 => {
                    self.co2 = is.read_int32()?;
                },
                40 => {
                    self.creatinine = is.read_int32()?;
                },
                48 => {
                    self.growth = is.read_int32()?;
                },
                56 => {
                    self.hunger = is.read_int32()?;
                },
                64 => {
                    self.asphyxia = is.read_int32()?;
                },
                72 => {
                    self.inflammation = is.read_int32()?;
                },
                80 => {
                    self.g_csf = is.read_int32()?;
                },
                88 => {
                    self.m_csf = is.read_int32()?;
                },
                96 => {
                    self.il_3 = is.read_int32()?;
                },
                104 => {
                    self.il_2 = is.read_int32()?;
                },
                112 => {
                    self.viral_load = is.read_int32()?;
                },
                120 => {
                    self.antibody_load = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.o2 != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.o2);
        }
        if self.glucose != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.glucose);
        }
        if self.vitamin != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.vitamin);
        }
        if self.co2 != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.co2);
        }
        if self.creatinine != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.creatinine);
        }
        if self.growth != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.growth);
        }
        if self.hunger != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.hunger);
        }
        if self.asphyxia != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.asphyxia);
        }
        if self.inflammation != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.inflammation);
        }
        if self.g_csf != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.g_csf);
        }
        if self.m_csf != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.m_csf);
        }
        if self.il_3 != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.il_3);
        }
        if self.il_2 != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.il_2);
        }
        if self.viral_load != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.viral_load);
        }
        if self.antibody_load != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.antibody_load);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.o2 != 0 {
            os.write_int32(1, self.o2)?;
        }
        if self.glucose != 0 {
            os.write_int32(2, self.glucose)?;
        }
        if self.vitamin != 0 {
            os.write_int32(3, self.vitamin)?;
        }
        if self.co2 != 0 {
            os.write_int32(4, self.co2)?;
        }
        if self.creatinine != 0 {
            os.write_int32(5, self.creatinine)?;
        }
        if self.growth != 0 {
            os.write_int32(6, self.growth)?;
        }
        if self.hunger != 0 {
            os.write_int32(7, self.hunger)?;
        }
        if self.asphyxia != 0 {
            os.write_int32(8, self.asphyxia)?;
        }
        if self.inflammation != 0 {
            os.write_int32(9, self.inflammation)?;
        }
        if self.g_csf != 0 {
            os.write_int32(10, self.g_csf)?;
        }
        if self.m_csf != 0 {
            os.write_int32(11, self.m_csf)?;
        }
        if self.il_3 != 0 {
            os.write_int32(12, self.il_3)?;
        }
        if self.il_2 != 0 {
            os.write_int32(13, self.il_2)?;
        }
        if self.viral_load != 0 {
            os.write_int32(14, self.viral_load)?;
        }
        if self.antibody_load != 0 {
            os.write_int32(15, self.antibody_load)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MaterialStatusSocketData {
        MaterialStatusSocketData::new()
    }

    fn clear(&mut self) {
        self.o2 = 0;
        self.glucose = 0;
        self.vitamin = 0;
        self.co2 = 0;
        self.creatinine = 0;
        self.growth = 0;
        self.hunger = 0;
        self.asphyxia = 0;
        self.inflammation = 0;
        self.g_csf = 0;
        self.m_csf = 0;
        self.il_3 = 0;
        self.il_2 = 0;
        self.viral_load = 0;
        self.antibody_load = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MaterialStatusSocketData {
        static instance: MaterialStatusSocketData = MaterialStatusSocketData {
            o2: 0,
            glucose: 0,
            vitamin: 0,
            co2: 0,
            creatinine: 0,
            growth: 0,
            hunger: 0,
            asphyxia: 0,
            inflammation: 0,
            g_csf: 0,
            m_csf: 0,
            il_3: 0,
            il_2: 0,
            viral_load: 0,
            antibody_load: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MaterialStatusSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MaterialStatusSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MaterialStatusSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialStatusSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.StatusSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatusSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.StatusSocketData.status)
    pub status: i32,
    // @@protoc_insertion_point(field:efflux.StatusSocketData.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.StatusSocketData.connections)
    pub connections: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:efflux.StatusSocketData.work_status)
    pub work_status: ::std::vec::Vec<WorkStatusSocketData>,
    // @@protoc_insertion_point(field:efflux.StatusSocketData.material_status)
    pub material_status: ::protobuf::MessageField<MaterialStatusSocketData>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.StatusSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusSocketData {
    fn default() -> &'a StatusSocketData {
        <StatusSocketData as ::protobuf::Message>::default_instance()
    }
}

impl StatusSocketData {
    pub fn new() -> StatusSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &StatusSocketData| { &m.status },
            |m: &mut StatusSocketData| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &StatusSocketData| { &m.name },
            |m: &mut StatusSocketData| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &StatusSocketData| { &m.connections },
            |m: &mut StatusSocketData| { &mut m.connections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "work_status",
            |m: &StatusSocketData| { &m.work_status },
            |m: &mut StatusSocketData| { &mut m.work_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MaterialStatusSocketData>(
            "material_status",
            |m: &StatusSocketData| { &m.material_status },
            |m: &mut StatusSocketData| { &mut m.material_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusSocketData>(
            "StatusSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusSocketData {
    const NAME: &'static str = "StatusSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.connections.push(is.read_string()?);
                },
                34 => {
                    self.work_status.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.material_status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.status);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.connections {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.work_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.material_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.connections {
            os.write_string(3, &v)?;
        };
        for v in &self.work_status {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.material_status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusSocketData {
        StatusSocketData::new()
    }

    fn clear(&mut self) {
        self.status = 0;
        self.name.clear();
        self.connections.clear();
        self.work_status.clear();
        self.material_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusSocketData {
        static instance: StatusSocketData = StatusSocketData {
            status: 0,
            name: ::std::string::String::new(),
            connections: ::std::vec::Vec::new(),
            work_status: ::std::vec::Vec::new(),
            material_status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.RenderableSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RenderableSocketData {
    // message fields
    // @@protoc_insertion_point(field:efflux.RenderableSocketData.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.RenderableSocketData.visible)
    pub visible: bool,
    // @@protoc_insertion_point(field:efflux.RenderableSocketData.position)
    pub position: ::protobuf::MessageField<Position>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.RenderableSocketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenderableSocketData {
    fn default() -> &'a RenderableSocketData {
        <RenderableSocketData as ::protobuf::Message>::default_instance()
    }
}

impl RenderableSocketData {
    pub fn new() -> RenderableSocketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RenderableSocketData| { &m.id },
            |m: &mut RenderableSocketData| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visible",
            |m: &RenderableSocketData| { &m.visible },
            |m: &mut RenderableSocketData| { &mut m.visible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &RenderableSocketData| { &m.position },
            |m: &mut RenderableSocketData| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenderableSocketData>(
            "RenderableSocketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenderableSocketData {
    const NAME: &'static str = "RenderableSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.visible = is.read_bool()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.visible != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.visible != false {
            os.write_bool(2, self.visible)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenderableSocketData {
        RenderableSocketData::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.visible = false;
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenderableSocketData {
        static instance: RenderableSocketData = RenderableSocketData {
            id: ::std::string::String::new(),
            visible: false,
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenderableSocketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenderableSocketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenderableSocketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenderableSocketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:efflux.Position.x)
    pub x: i32,
    // @@protoc_insertion_point(field:efflux.Position.y)
    pub y: i32,
    // @@protoc_insertion_point(field:efflux.Position.z)
    pub z: i32,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &Position| { &m.x },
            |m: &mut Position| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &Position| { &m.y },
            |m: &mut Position| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "z",
            |m: &Position| { &m.z },
            |m: &mut Position| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_int32()?;
                },
                16 => {
                    self.y = is.read_int32()?;
                },
                24 => {
                    self.z = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.y);
        }
        if self.z != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.z);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        if self.z != 0 {
            os.write_int32(3, self.z)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.z = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            x: 0,
            y: 0,
            z: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.CellStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CellStatus {
    // message fields
    // @@protoc_insertion_point(field:efflux.CellStatus.timestamp)
    pub timestamp: i64,
    // @@protoc_insertion_point(field:efflux.CellStatus.cell_type)
    pub cell_type: ::protobuf::EnumOrUnknown<CellType>,
    // @@protoc_insertion_point(field:efflux.CellStatus.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.CellStatus.render_id)
    pub render_id: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.CellStatus.damage)
    pub damage: i32,
    // @@protoc_insertion_point(field:efflux.CellStatus.spawn_time)
    pub spawn_time: i64,
    // @@protoc_insertion_point(field:efflux.CellStatus.viral_load)
    pub viral_load: i64,
    // @@protoc_insertion_point(field:efflux.CellStatus.transport_path)
    pub transport_path: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:efflux.CellStatus.want_path)
    pub want_path: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:efflux.CellStatus.proteins)
    pub proteins: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:efflux.CellStatus.presented)
    pub presented: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:efflux.CellStatus.cell_actions)
    pub cell_actions: ::std::vec::Vec<::protobuf::EnumOrUnknown<CellActionStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.CellStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CellStatus {
    fn default() -> &'a CellStatus {
        <CellStatus as ::protobuf::Message>::default_instance()
    }
}

impl CellStatus {
    pub fn new() -> CellStatus {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &CellStatus| { &m.timestamp },
            |m: &mut CellStatus| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cell_type",
            |m: &CellStatus| { &m.cell_type },
            |m: &mut CellStatus| { &mut m.cell_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CellStatus| { &m.name },
            |m: &mut CellStatus| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "render_id",
            |m: &CellStatus| { &m.render_id },
            |m: &mut CellStatus| { &mut m.render_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "damage",
            |m: &CellStatus| { &m.damage },
            |m: &mut CellStatus| { &mut m.damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spawn_time",
            |m: &CellStatus| { &m.spawn_time },
            |m: &mut CellStatus| { &mut m.spawn_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "viral_load",
            |m: &CellStatus| { &m.viral_load },
            |m: &mut CellStatus| { &mut m.viral_load },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transport_path",
            |m: &CellStatus| { &m.transport_path },
            |m: &mut CellStatus| { &mut m.transport_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "want_path",
            |m: &CellStatus| { &m.want_path },
            |m: &mut CellStatus| { &mut m.want_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proteins",
            |m: &CellStatus| { &m.proteins },
            |m: &mut CellStatus| { &mut m.proteins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "presented",
            |m: &CellStatus| { &m.presented },
            |m: &mut CellStatus| { &mut m.presented },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cell_actions",
            |m: &CellStatus| { &m.cell_actions },
            |m: &mut CellStatus| { &mut m.cell_actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CellStatus>(
            "CellStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CellStatus {
    const NAME: &'static str = "CellStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = is.read_int64()?;
                },
                16 => {
                    self.cell_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.render_id = is.read_string()?;
                },
                40 => {
                    self.damage = is.read_int32()?;
                },
                48 => {
                    self.spawn_time = is.read_int64()?;
                },
                56 => {
                    self.viral_load = is.read_int64()?;
                },
                66 => {
                    self.transport_path.push(is.read_string()?);
                },
                74 => {
                    self.want_path.push(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.proteins)?;
                },
                80 => {
                    self.proteins.push(is.read_uint32()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.presented)?;
                },
                88 => {
                    self.presented.push(is.read_uint32()?);
                },
                96 => {
                    self.cell_actions.push(is.read_enum_or_unknown()?);
                },
                98 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.cell_actions)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.timestamp);
        }
        if self.cell_type != ::protobuf::EnumOrUnknown::new(CellType::Bacteria) {
            my_size += ::protobuf::rt::int32_size(2, self.cell_type.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.render_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.render_id);
        }
        if self.damage != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.damage);
        }
        if self.spawn_time != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.spawn_time);
        }
        if self.viral_load != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.viral_load);
        }
        for value in &self.transport_path {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.want_path {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::vec_packed_uint32_size(10, &self.proteins);
        my_size += ::protobuf::rt::vec_packed_uint32_size(11, &self.presented);
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(12, &self.cell_actions);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if self.cell_type != ::protobuf::EnumOrUnknown::new(CellType::Bacteria) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.cell_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.render_id.is_empty() {
            os.write_string(4, &self.render_id)?;
        }
        if self.damage != 0 {
            os.write_int32(5, self.damage)?;
        }
        if self.spawn_time != 0 {
            os.write_int64(6, self.spawn_time)?;
        }
        if self.viral_load != 0 {
            os.write_int64(7, self.viral_load)?;
        }
        for v in &self.transport_path {
            os.write_string(8, &v)?;
        };
        for v in &self.want_path {
            os.write_string(9, &v)?;
        };
        os.write_repeated_packed_uint32(10, &self.proteins)?;
        os.write_repeated_packed_uint32(11, &self.presented)?;
        os.write_repeated_packed_enum_or_unknown(12, &self.cell_actions)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CellStatus {
        CellStatus::new()
    }

    fn clear(&mut self) {
        self.timestamp = 0;
        self.cell_type = ::protobuf::EnumOrUnknown::new(CellType::Bacteria);
        self.name.clear();
        self.render_id.clear();
        self.damage = 0;
        self.spawn_time = 0;
        self.viral_load = 0;
        self.transport_path.clear();
        self.want_path.clear();
        self.proteins.clear();
        self.presented.clear();
        self.cell_actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CellStatus {
        static instance: CellStatus = CellStatus {
            timestamp: 0,
            cell_type: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            render_id: ::std::string::String::new(),
            damage: 0,
            spawn_time: 0,
            viral_load: 0,
            transport_path: ::std::vec::Vec::new(),
            want_path: ::std::vec::Vec::new(),
            proteins: ::std::vec::Vec::new(),
            presented: ::std::vec::Vec::new(),
            cell_actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CellStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CellStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CellStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CellStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.InteractionLoginRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InteractionLoginRequest {
    // message fields
    // @@protoc_insertion_point(field:efflux.InteractionLoginRequest.session_token)
    pub session_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.InteractionLoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractionLoginRequest {
    fn default() -> &'a InteractionLoginRequest {
        <InteractionLoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl InteractionLoginRequest {
    pub fn new() -> InteractionLoginRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_token",
            |m: &InteractionLoginRequest| { &m.session_token },
            |m: &mut InteractionLoginRequest| { &mut m.session_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractionLoginRequest>(
            "InteractionLoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractionLoginRequest {
    const NAME: &'static str = "InteractionLoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session_token.is_empty() {
            os.write_string(1, &self.session_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractionLoginRequest {
        InteractionLoginRequest::new()
    }

    fn clear(&mut self) {
        self.session_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractionLoginRequest {
        static instance: InteractionLoginRequest = InteractionLoginRequest {
            session_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractionLoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractionLoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractionLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractionLoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.InteractionLoginResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InteractionLoginResponse {
    // message fields
    // @@protoc_insertion_point(field:efflux.InteractionLoginResponse.session_token)
    pub session_token: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.InteractionLoginResponse.expiry)
    pub expiry: i32,
    // @@protoc_insertion_point(field:efflux.InteractionLoginResponse.render_id)
    pub render_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.InteractionLoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractionLoginResponse {
    fn default() -> &'a InteractionLoginResponse {
        <InteractionLoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl InteractionLoginResponse {
    pub fn new() -> InteractionLoginResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_token",
            |m: &InteractionLoginResponse| { &m.session_token },
            |m: &mut InteractionLoginResponse| { &mut m.session_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expiry",
            |m: &InteractionLoginResponse| { &m.expiry },
            |m: &mut InteractionLoginResponse| { &mut m.expiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "render_id",
            |m: &InteractionLoginResponse| { &m.render_id },
            |m: &mut InteractionLoginResponse| { &mut m.render_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractionLoginResponse>(
            "InteractionLoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractionLoginResponse {
    const NAME: &'static str = "InteractionLoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_token = is.read_string()?;
                },
                16 => {
                    self.expiry = is.read_int32()?;
                },
                26 => {
                    self.render_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_token);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.expiry);
        }
        if !self.render_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.render_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session_token.is_empty() {
            os.write_string(1, &self.session_token)?;
        }
        if self.expiry != 0 {
            os.write_int32(2, self.expiry)?;
        }
        if !self.render_id.is_empty() {
            os.write_string(3, &self.render_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractionLoginResponse {
        InteractionLoginResponse::new()
    }

    fn clear(&mut self) {
        self.session_token.clear();
        self.expiry = 0;
        self.render_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractionLoginResponse {
        static instance: InteractionLoginResponse = InteractionLoginResponse {
            session_token: ::std::string::String::new(),
            expiry: 0,
            render_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractionLoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractionLoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractionLoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractionLoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.InteractionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InteractionRequest {
    // message fields
    // @@protoc_insertion_point(field:efflux.InteractionRequest.session_token)
    pub session_token: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.InteractionRequest.type)
    pub type_: ::protobuf::EnumOrUnknown<InteractionType>,
    // @@protoc_insertion_point(field:efflux.InteractionRequest.position)
    pub position: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:efflux.InteractionRequest.target_cell)
    pub target_cell: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.InteractionRequest.cytokine_type)
    pub cytokine_type: ::protobuf::EnumOrUnknown<CytokineType>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.InteractionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractionRequest {
    fn default() -> &'a InteractionRequest {
        <InteractionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InteractionRequest {
    pub fn new() -> InteractionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_token",
            |m: &InteractionRequest| { &m.session_token },
            |m: &mut InteractionRequest| { &mut m.session_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &InteractionRequest| { &m.type_ },
            |m: &mut InteractionRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "position",
            |m: &InteractionRequest| { &m.position },
            |m: &mut InteractionRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_cell",
            |m: &InteractionRequest| { &m.target_cell },
            |m: &mut InteractionRequest| { &mut m.target_cell },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cytokine_type",
            |m: &InteractionRequest| { &m.cytokine_type },
            |m: &mut InteractionRequest| { &mut m.cytokine_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractionRequest>(
            "InteractionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractionRequest {
    const NAME: &'static str = "InteractionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.session_token = is.read_string()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                34 => {
                    self.target_cell = is.read_string()?;
                },
                40 => {
                    self.cytokine_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.session_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_token);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(InteractionType::ping) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.target_cell.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.target_cell);
        }
        if self.cytokine_type != ::protobuf::EnumOrUnknown::new(CytokineType::unknown) {
            my_size += ::protobuf::rt::int32_size(5, self.cytokine_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.session_token.is_empty() {
            os.write_string(1, &self.session_token)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(InteractionType::ping) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.target_cell.is_empty() {
            os.write_string(4, &self.target_cell)?;
        }
        if self.cytokine_type != ::protobuf::EnumOrUnknown::new(CytokineType::unknown) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.cytokine_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractionRequest {
        InteractionRequest::new()
    }

    fn clear(&mut self) {
        self.session_token.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(InteractionType::ping);
        self.position.clear();
        self.target_cell.clear();
        self.cytokine_type = ::protobuf::EnumOrUnknown::new(CytokineType::unknown);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractionRequest {
        static instance: InteractionRequest = InteractionRequest {
            session_token: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            position: ::protobuf::MessageField::none(),
            target_cell: ::std::string::String::new(),
            cytokine_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:efflux.InteractionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InteractionResponse {
    // message fields
    // @@protoc_insertion_point(field:efflux.InteractionResponse.type)
    pub type_: ::protobuf::EnumOrUnknown<InteractionType>,
    // @@protoc_insertion_point(field:efflux.InteractionResponse.status)
    pub status: ::protobuf::EnumOrUnknown<interaction_response::Status>,
    // @@protoc_insertion_point(field:efflux.InteractionResponse.error_message)
    pub error_message: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.InteractionResponse.attached_to)
    pub attached_to: ::std::string::String,
    // @@protoc_insertion_point(field:efflux.InteractionResponse.target_cell_status)
    pub target_cell_status: ::protobuf::MessageField<CellStatus>,
    // @@protoc_insertion_point(field:efflux.InteractionResponse.attached_cell_status)
    pub attached_cell_status: ::protobuf::MessageField<CellStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:efflux.InteractionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractionResponse {
    fn default() -> &'a InteractionResponse {
        <InteractionResponse as ::protobuf::Message>::default_instance()
    }
}

impl InteractionResponse {
    pub fn new() -> InteractionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &InteractionResponse| { &m.type_ },
            |m: &mut InteractionResponse| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &InteractionResponse| { &m.status },
            |m: &mut InteractionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_message",
            |m: &InteractionResponse| { &m.error_message },
            |m: &mut InteractionResponse| { &mut m.error_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attached_to",
            |m: &InteractionResponse| { &m.attached_to },
            |m: &mut InteractionResponse| { &mut m.attached_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CellStatus>(
            "target_cell_status",
            |m: &InteractionResponse| { &m.target_cell_status },
            |m: &mut InteractionResponse| { &mut m.target_cell_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CellStatus>(
            "attached_cell_status",
            |m: &InteractionResponse| { &m.attached_cell_status },
            |m: &mut InteractionResponse| { &mut m.attached_cell_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractionResponse>(
            "InteractionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractionResponse {
    const NAME: &'static str = "InteractionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.error_message = is.read_string()?;
                },
                34 => {
                    self.attached_to = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_cell_status)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attached_cell_status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(InteractionType::ping) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.status != ::protobuf::EnumOrUnknown::new(interaction_response::Status::failure) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error_message);
        }
        if !self.attached_to.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.attached_to);
        }
        if let Some(v) = self.target_cell_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.attached_cell_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(InteractionType::ping) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(interaction_response::Status::failure) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.error_message.is_empty() {
            os.write_string(3, &self.error_message)?;
        }
        if !self.attached_to.is_empty() {
            os.write_string(4, &self.attached_to)?;
        }
        if let Some(v) = self.target_cell_status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.attached_cell_status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractionResponse {
        InteractionResponse::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(InteractionType::ping);
        self.status = ::protobuf::EnumOrUnknown::new(interaction_response::Status::failure);
        self.error_message.clear();
        self.attached_to.clear();
        self.target_cell_status.clear();
        self.attached_cell_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractionResponse {
        static instance: InteractionResponse = InteractionResponse {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            error_message: ::std::string::String::new(),
            attached_to: ::std::string::String::new(),
            target_cell_status: ::protobuf::MessageField::none(),
            attached_cell_status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractionResponse`
pub mod interaction_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:efflux.InteractionResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:efflux.InteractionResponse.Status.failure)
        failure = 0,
        // @@protoc_insertion_point(enum_value:efflux.InteractionResponse.Status.success)
        success = 1,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::failure),
                1 => ::std::option::Option::Some(Status::success),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "failure" => ::std::option::Option::Some(Status::failure),
                "success" => ::std::option::Option::Some(Status::success),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::failure,
            Status::success,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InteractionResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::failure
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("InteractionResponse.Status")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:efflux.CellType)
pub enum CellType {
    // @@protoc_insertion_point(enum_value:efflux.CellType.Bacteria)
    Bacteria = 0,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Bacteroidota)
    Bacteroidota = 1,
    // @@protoc_insertion_point(enum_value:efflux.CellType.RedBlood)
    RedBlood = 2,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Neuron)
    Neuron = 3,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Cardiomyocyte)
    Cardiomyocyte = 4,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Pneumocyte)
    Pneumocyte = 5,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Myocyte)
    Myocyte = 6,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Keratinocyte)
    Keratinocyte = 7,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Enterocyte)
    Enterocyte = 8,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Podocyte)
    Podocyte = 9,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Hemocytoblast)
    Hemocytoblast = 10,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Lymphoblast)
    Lymphoblast = 11,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Myeloblast)
    Myeloblast = 12,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Monocyte)
    Monocyte = 13,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Macrophagocyte)
    Macrophagocyte = 14,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Dendritic)
    Dendritic = 15,
    // @@protoc_insertion_point(enum_value:efflux.CellType.Neutrocyte)
    Neutrocyte = 16,
    // @@protoc_insertion_point(enum_value:efflux.CellType.NaturalKillerCell)
    NaturalKillerCell = 17,
    // @@protoc_insertion_point(enum_value:efflux.CellType.VirginTLymphocyte)
    VirginTLymphocyte = 18,
    // @@protoc_insertion_point(enum_value:efflux.CellType.HelperTLymphocyte)
    HelperTLymphocyte = 19,
    // @@protoc_insertion_point(enum_value:efflux.CellType.KillerTLymphocyte)
    KillerTLymphocyte = 20,
    // @@protoc_insertion_point(enum_value:efflux.CellType.BLymphocyte)
    BLymphocyte = 21,
    // @@protoc_insertion_point(enum_value:efflux.CellType.EffectorBLymphocyte)
    EffectorBLymphocyte = 22,
    // @@protoc_insertion_point(enum_value:efflux.CellType.ViralLoadCarrier)
    ViralLoadCarrier = 23,
}

impl ::protobuf::Enum for CellType {
    const NAME: &'static str = "CellType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CellType> {
        match value {
            0 => ::std::option::Option::Some(CellType::Bacteria),
            1 => ::std::option::Option::Some(CellType::Bacteroidota),
            2 => ::std::option::Option::Some(CellType::RedBlood),
            3 => ::std::option::Option::Some(CellType::Neuron),
            4 => ::std::option::Option::Some(CellType::Cardiomyocyte),
            5 => ::std::option::Option::Some(CellType::Pneumocyte),
            6 => ::std::option::Option::Some(CellType::Myocyte),
            7 => ::std::option::Option::Some(CellType::Keratinocyte),
            8 => ::std::option::Option::Some(CellType::Enterocyte),
            9 => ::std::option::Option::Some(CellType::Podocyte),
            10 => ::std::option::Option::Some(CellType::Hemocytoblast),
            11 => ::std::option::Option::Some(CellType::Lymphoblast),
            12 => ::std::option::Option::Some(CellType::Myeloblast),
            13 => ::std::option::Option::Some(CellType::Monocyte),
            14 => ::std::option::Option::Some(CellType::Macrophagocyte),
            15 => ::std::option::Option::Some(CellType::Dendritic),
            16 => ::std::option::Option::Some(CellType::Neutrocyte),
            17 => ::std::option::Option::Some(CellType::NaturalKillerCell),
            18 => ::std::option::Option::Some(CellType::VirginTLymphocyte),
            19 => ::std::option::Option::Some(CellType::HelperTLymphocyte),
            20 => ::std::option::Option::Some(CellType::KillerTLymphocyte),
            21 => ::std::option::Option::Some(CellType::BLymphocyte),
            22 => ::std::option::Option::Some(CellType::EffectorBLymphocyte),
            23 => ::std::option::Option::Some(CellType::ViralLoadCarrier),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CellType> {
        match str {
            "Bacteria" => ::std::option::Option::Some(CellType::Bacteria),
            "Bacteroidota" => ::std::option::Option::Some(CellType::Bacteroidota),
            "RedBlood" => ::std::option::Option::Some(CellType::RedBlood),
            "Neuron" => ::std::option::Option::Some(CellType::Neuron),
            "Cardiomyocyte" => ::std::option::Option::Some(CellType::Cardiomyocyte),
            "Pneumocyte" => ::std::option::Option::Some(CellType::Pneumocyte),
            "Myocyte" => ::std::option::Option::Some(CellType::Myocyte),
            "Keratinocyte" => ::std::option::Option::Some(CellType::Keratinocyte),
            "Enterocyte" => ::std::option::Option::Some(CellType::Enterocyte),
            "Podocyte" => ::std::option::Option::Some(CellType::Podocyte),
            "Hemocytoblast" => ::std::option::Option::Some(CellType::Hemocytoblast),
            "Lymphoblast" => ::std::option::Option::Some(CellType::Lymphoblast),
            "Myeloblast" => ::std::option::Option::Some(CellType::Myeloblast),
            "Monocyte" => ::std::option::Option::Some(CellType::Monocyte),
            "Macrophagocyte" => ::std::option::Option::Some(CellType::Macrophagocyte),
            "Dendritic" => ::std::option::Option::Some(CellType::Dendritic),
            "Neutrocyte" => ::std::option::Option::Some(CellType::Neutrocyte),
            "NaturalKillerCell" => ::std::option::Option::Some(CellType::NaturalKillerCell),
            "VirginTLymphocyte" => ::std::option::Option::Some(CellType::VirginTLymphocyte),
            "HelperTLymphocyte" => ::std::option::Option::Some(CellType::HelperTLymphocyte),
            "KillerTLymphocyte" => ::std::option::Option::Some(CellType::KillerTLymphocyte),
            "BLymphocyte" => ::std::option::Option::Some(CellType::BLymphocyte),
            "EffectorBLymphocyte" => ::std::option::Option::Some(CellType::EffectorBLymphocyte),
            "ViralLoadCarrier" => ::std::option::Option::Some(CellType::ViralLoadCarrier),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CellType] = &[
        CellType::Bacteria,
        CellType::Bacteroidota,
        CellType::RedBlood,
        CellType::Neuron,
        CellType::Cardiomyocyte,
        CellType::Pneumocyte,
        CellType::Myocyte,
        CellType::Keratinocyte,
        CellType::Enterocyte,
        CellType::Podocyte,
        CellType::Hemocytoblast,
        CellType::Lymphoblast,
        CellType::Myeloblast,
        CellType::Monocyte,
        CellType::Macrophagocyte,
        CellType::Dendritic,
        CellType::Neutrocyte,
        CellType::NaturalKillerCell,
        CellType::VirginTLymphocyte,
        CellType::HelperTLymphocyte,
        CellType::KillerTLymphocyte,
        CellType::BLymphocyte,
        CellType::EffectorBLymphocyte,
        CellType::ViralLoadCarrier,
    ];
}

impl ::protobuf::EnumFull for CellType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CellType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CellType {
    fn default() -> Self {
        CellType::Bacteria
    }
}

impl CellType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CellType>("CellType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:efflux.WorkType)
pub enum WorkType {
    // @@protoc_insertion_point(enum_value:efflux.WorkType.nothing)
    nothing = 0,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.diffusion)
    diffusion = 1,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.cover)
    cover = 2,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.exchange)
    exchange = 3,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.exhale)
    exhale = 4,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.pump)
    pump = 5,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.move)
    move_ = 6,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.think)
    think = 7,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.digest)
    digest = 8,
    // @@protoc_insertion_point(enum_value:efflux.WorkType.filter)
    filter = 9,
}

impl ::protobuf::Enum for WorkType {
    const NAME: &'static str = "WorkType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkType> {
        match value {
            0 => ::std::option::Option::Some(WorkType::nothing),
            1 => ::std::option::Option::Some(WorkType::diffusion),
            2 => ::std::option::Option::Some(WorkType::cover),
            3 => ::std::option::Option::Some(WorkType::exchange),
            4 => ::std::option::Option::Some(WorkType::exhale),
            5 => ::std::option::Option::Some(WorkType::pump),
            6 => ::std::option::Option::Some(WorkType::move_),
            7 => ::std::option::Option::Some(WorkType::think),
            8 => ::std::option::Option::Some(WorkType::digest),
            9 => ::std::option::Option::Some(WorkType::filter),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<WorkType> {
        match str {
            "nothing" => ::std::option::Option::Some(WorkType::nothing),
            "diffusion" => ::std::option::Option::Some(WorkType::diffusion),
            "cover" => ::std::option::Option::Some(WorkType::cover),
            "exchange" => ::std::option::Option::Some(WorkType::exchange),
            "exhale" => ::std::option::Option::Some(WorkType::exhale),
            "pump" => ::std::option::Option::Some(WorkType::pump),
            "move" => ::std::option::Option::Some(WorkType::move_),
            "think" => ::std::option::Option::Some(WorkType::think),
            "digest" => ::std::option::Option::Some(WorkType::digest),
            "filter" => ::std::option::Option::Some(WorkType::filter),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WorkType] = &[
        WorkType::nothing,
        WorkType::diffusion,
        WorkType::cover,
        WorkType::exchange,
        WorkType::exhale,
        WorkType::pump,
        WorkType::move_,
        WorkType::think,
        WorkType::digest,
        WorkType::filter,
    ];
}

impl ::protobuf::EnumFull for WorkType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WorkType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WorkType {
    fn default() -> Self {
        WorkType::nothing
    }
}

impl WorkType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WorkType>("WorkType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:efflux.CytokineType)
pub enum CytokineType {
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.unknown)
    unknown = 0,
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.cell_damage)
    cell_damage = 1,
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.cell_stressed)
    cell_stressed = 2,
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.antigen_present)
    antigen_present = 3,
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.induce_chemotaxis)
    induce_chemotaxis = 4,
    // @@protoc_insertion_point(enum_value:efflux.CytokineType.cytotoxins)
    cytotoxins = 5,
}

impl ::protobuf::Enum for CytokineType {
    const NAME: &'static str = "CytokineType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CytokineType> {
        match value {
            0 => ::std::option::Option::Some(CytokineType::unknown),
            1 => ::std::option::Option::Some(CytokineType::cell_damage),
            2 => ::std::option::Option::Some(CytokineType::cell_stressed),
            3 => ::std::option::Option::Some(CytokineType::antigen_present),
            4 => ::std::option::Option::Some(CytokineType::induce_chemotaxis),
            5 => ::std::option::Option::Some(CytokineType::cytotoxins),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CytokineType> {
        match str {
            "unknown" => ::std::option::Option::Some(CytokineType::unknown),
            "cell_damage" => ::std::option::Option::Some(CytokineType::cell_damage),
            "cell_stressed" => ::std::option::Option::Some(CytokineType::cell_stressed),
            "antigen_present" => ::std::option::Option::Some(CytokineType::antigen_present),
            "induce_chemotaxis" => ::std::option::Option::Some(CytokineType::induce_chemotaxis),
            "cytotoxins" => ::std::option::Option::Some(CytokineType::cytotoxins),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CytokineType] = &[
        CytokineType::unknown,
        CytokineType::cell_damage,
        CytokineType::cell_stressed,
        CytokineType::antigen_present,
        CytokineType::induce_chemotaxis,
        CytokineType::cytotoxins,
    ];
}

impl ::protobuf::EnumFull for CytokineType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CytokineType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CytokineType {
    fn default() -> Self {
        CytokineType::unknown
    }
}

impl CytokineType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CytokineType>("CytokineType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:efflux.CellActionStatus)
pub enum CellActionStatus {
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.do_nothing)
    do_nothing = 0,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.repair)
    repair = 1,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.incur_damage)
    incur_damage = 2,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.despawn)
    despawn = 3,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.apoptosis)
    apoptosis = 4,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.do_work)
    do_work = 5,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.transport)
    transport = 6,
    // @@protoc_insertion_point(enum_value:efflux.CellActionStatus.mitosis)
    mitosis = 7,
}

impl ::protobuf::Enum for CellActionStatus {
    const NAME: &'static str = "CellActionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CellActionStatus> {
        match value {
            0 => ::std::option::Option::Some(CellActionStatus::do_nothing),
            1 => ::std::option::Option::Some(CellActionStatus::repair),
            2 => ::std::option::Option::Some(CellActionStatus::incur_damage),
            3 => ::std::option::Option::Some(CellActionStatus::despawn),
            4 => ::std::option::Option::Some(CellActionStatus::apoptosis),
            5 => ::std::option::Option::Some(CellActionStatus::do_work),
            6 => ::std::option::Option::Some(CellActionStatus::transport),
            7 => ::std::option::Option::Some(CellActionStatus::mitosis),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CellActionStatus> {
        match str {
            "do_nothing" => ::std::option::Option::Some(CellActionStatus::do_nothing),
            "repair" => ::std::option::Option::Some(CellActionStatus::repair),
            "incur_damage" => ::std::option::Option::Some(CellActionStatus::incur_damage),
            "despawn" => ::std::option::Option::Some(CellActionStatus::despawn),
            "apoptosis" => ::std::option::Option::Some(CellActionStatus::apoptosis),
            "do_work" => ::std::option::Option::Some(CellActionStatus::do_work),
            "transport" => ::std::option::Option::Some(CellActionStatus::transport),
            "mitosis" => ::std::option::Option::Some(CellActionStatus::mitosis),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CellActionStatus] = &[
        CellActionStatus::do_nothing,
        CellActionStatus::repair,
        CellActionStatus::incur_damage,
        CellActionStatus::despawn,
        CellActionStatus::apoptosis,
        CellActionStatus::do_work,
        CellActionStatus::transport,
        CellActionStatus::mitosis,
    ];
}

impl ::protobuf::EnumFull for CellActionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CellActionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CellActionStatus {
    fn default() -> Self {
        CellActionStatus::do_nothing
    }
}

impl CellActionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CellActionStatus>("CellActionStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:efflux.InteractionType)
pub enum InteractionType {
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.ping)
    ping = 0,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.close)
    close = 1,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.move_to)
    move_to = 2,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.follow)
    follow = 3,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.attach)
    attach = 4,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.detach)
    detach = 5,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.info)
    info = 6,
    // @@protoc_insertion_point(enum_value:efflux.InteractionType.drop_cytokine)
    drop_cytokine = 7,
}

impl ::protobuf::Enum for InteractionType {
    const NAME: &'static str = "InteractionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InteractionType> {
        match value {
            0 => ::std::option::Option::Some(InteractionType::ping),
            1 => ::std::option::Option::Some(InteractionType::close),
            2 => ::std::option::Option::Some(InteractionType::move_to),
            3 => ::std::option::Option::Some(InteractionType::follow),
            4 => ::std::option::Option::Some(InteractionType::attach),
            5 => ::std::option::Option::Some(InteractionType::detach),
            6 => ::std::option::Option::Some(InteractionType::info),
            7 => ::std::option::Option::Some(InteractionType::drop_cytokine),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<InteractionType> {
        match str {
            "ping" => ::std::option::Option::Some(InteractionType::ping),
            "close" => ::std::option::Option::Some(InteractionType::close),
            "move_to" => ::std::option::Option::Some(InteractionType::move_to),
            "follow" => ::std::option::Option::Some(InteractionType::follow),
            "attach" => ::std::option::Option::Some(InteractionType::attach),
            "detach" => ::std::option::Option::Some(InteractionType::detach),
            "info" => ::std::option::Option::Some(InteractionType::info),
            "drop_cytokine" => ::std::option::Option::Some(InteractionType::drop_cytokine),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InteractionType] = &[
        InteractionType::ping,
        InteractionType::close,
        InteractionType::move_to,
        InteractionType::follow,
        InteractionType::attach,
        InteractionType::detach,
        InteractionType::info,
        InteractionType::drop_cytokine,
    ];
}

impl ::protobuf::EnumFull for InteractionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("InteractionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for InteractionType {
    fn default() -> Self {
        InteractionType::ping
    }
}

impl InteractionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InteractionType>("InteractionType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cefflux.proto\x12\x06efflux\"\x98\x01\n\x0eWorkSocketData\x12\x1b\n\
    \twork_type\x18\x01\x20\x01(\x05R\x08workType\x12\x16\n\x06result\x18\
    \x02\x20\x01(\tR\x06result\x12\x16\n\x06status\x18\x03\x20\x01(\x05R\x06\
    status\x129\n\tdiffusion\x18\x04\x20\x01(\x0b2\x1b.efflux.DiffusionSocke\
    tDataR\tdiffusion\"^\n\x16ResourceBlobSocketData\x12\x0e\n\x02o2\x18\x01\
    \x20\x01(\x05R\x02o2\x12\x18\n\x07glucose\x18\x02\x20\x01(\x05R\x07gluco\
    se\x12\x1a\n\x08vitamins\x18\x03\x20\x01(\x05R\x08vitamins\"H\n\x13Waste\
    BlobSocketData\x12\x11\n\x04c_o2\x18\x01\x20\x01(\x05R\x03cO2\x12\x1e\n\
    \ncreatinine\x18\x02\x20\x01(\x05R\ncreatinine\"\x83\x02\n\x15HormoneBlo\
    bSocketData\x12Q\n%granulocyte_colony_stimulating_factor\x18\x01\x20\x01\
    (\x05R\"granulocyteColonyStimulatingFactor\x12O\n$macrophage_colony_stim\
    ulating_factor\x18\x02\x20\x01(\x05R!macrophageColonyStimulatingFactor\
    \x12\"\n\x0cinterleukin3\x18\x03\x20\x01(\x05R\x0cinterleukin3\x12\"\n\
    \x0cinterleukin2\x18\x04\x20\x01(\x05R\x0cinterleukin2\"}\n\x15AntigenBl\
    obSocketData\x12+\n\x11antibody_proteins\x18\x01\x20\x03(\x05R\x10antibo\
    dyProteins\x127\n\x17antibody_concentrations\x18\x02\x20\x03(\x03R\x16an\
    tibodyConcentrations\"\xf8\x01\n\x13DiffusionSocketData\x12<\n\tresource\
    s\x18\x01\x20\x01(\x0b2\x1e.efflux.ResourceBlobSocketDataR\tresources\
    \x121\n\x05waste\x18\x02\x20\x01(\x0b2\x1b.efflux.WasteBlobSocketDataR\
    \x05waste\x127\n\x07hormone\x18\x03\x20\x01(\x0b2\x1d.efflux.HormoneBlob\
    SocketDataR\x07hormone\x127\n\x07antigen\x18\x04\x20\x01(\x0b2\x1d.efflu\
    x.AntigenBlobSocketDataR\x07antigen\"\x83\x02\n\x14WorkStatusSocketData\
    \x12\x1b\n\twork_type\x18\x01\x20\x01(\tR\x08workType\x12#\n\rrequest_co\
    unt\x18\x02\x20\x01(\x05R\x0crequestCount\x12#\n\rsuccess_count\x18\x03\
    \x20\x01(\x05R\x0csuccessCount\x12#\n\rfailure_count\x18\x04\x20\x01(\
    \x05R\x0cfailureCount\x12'\n\x0fcompleted_count\x18\x05\x20\x01(\x05R\
    \x0ecompletedCount\x126\n\x17completed_failure_count\x18\x06\x20\x01(\
    \x05R\x15completedFailureCount\"\x94\x03\n\x18MaterialStatusSocketData\
    \x12\x0e\n\x02o2\x18\x01\x20\x01(\x05R\x02o2\x12\x18\n\x07glucose\x18\
    \x02\x20\x01(\x05R\x07glucose\x12\x18\n\x07vitamin\x18\x03\x20\x01(\x05R\
    \x07vitamin\x12\x10\n\x03co2\x18\x04\x20\x01(\x05R\x03co2\x12\x1e\n\ncre\
    atinine\x18\x05\x20\x01(\x05R\ncreatinine\x12\x16\n\x06growth\x18\x06\
    \x20\x01(\x05R\x06growth\x12\x16\n\x06hunger\x18\x07\x20\x01(\x05R\x06hu\
    nger\x12\x1a\n\x08asphyxia\x18\x08\x20\x01(\x05R\x08asphyxia\x12\"\n\x0c\
    inflammation\x18\t\x20\x01(\x05R\x0cinflammation\x12\x13\n\x05g_csf\x18\
    \n\x20\x01(\x05R\x04gCsf\x12\x13\n\x05m_csf\x18\x0b\x20\x01(\x05R\x04mCs\
    f\x12\x11\n\x04il_3\x18\x0c\x20\x01(\x05R\x03il3\x12\x11\n\x04il_2\x18\r\
    \x20\x01(\x05R\x03il2\x12\x1d\n\nviral_load\x18\x0e\x20\x01(\x05R\tviral\
    Load\x12#\n\rantibody_load\x18\x0f\x20\x01(\x05R\x0cantibodyLoad\"\xea\
    \x01\n\x10StatusSocketData\x12\x16\n\x06status\x18\x01\x20\x01(\x05R\x06\
    status\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bconnec\
    tions\x18\x03\x20\x03(\tR\x0bconnections\x12=\n\x0bwork_status\x18\x04\
    \x20\x03(\x0b2\x1c.efflux.WorkStatusSocketDataR\nworkStatus\x12I\n\x0fma\
    terial_status\x18\x05\x20\x01(\x0b2\x20.efflux.MaterialStatusSocketDataR\
    \x0ematerialStatus\"n\n\x14RenderableSocketData\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x18\n\x07visible\x18\x02\x20\x01(\x08R\x07visible\
    \x12,\n\x08position\x18\x03\x20\x01(\x0b2\x10.efflux.PositionR\x08positi\
    on\"4\n\x08Position\x12\x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x01(\x05R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x05R\
    \x01z\"\x9b\x03\n\nCellStatus\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\
    \ttimestamp\x12-\n\tcell_type\x18\x02\x20\x01(\x0e2\x10.efflux.CellTypeR\
    \x08cellType\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tre\
    nder_id\x18\x04\x20\x01(\tR\x08renderId\x12\x16\n\x06damage\x18\x05\x20\
    \x01(\x05R\x06damage\x12\x1d\n\nspawn_time\x18\x06\x20\x01(\x03R\tspawnT\
    ime\x12\x1d\n\nviral_load\x18\x07\x20\x01(\x03R\tviralLoad\x12%\n\x0etra\
    nsport_path\x18\x08\x20\x03(\tR\rtransportPath\x12\x1b\n\twant_path\x18\
    \t\x20\x03(\tR\x08wantPath\x12\x1a\n\x08proteins\x18\n\x20\x03(\rR\x08pr\
    oteins\x12\x1c\n\tpresented\x18\x0b\x20\x03(\rR\tpresented\x12;\n\x0ccel\
    l_actions\x18\x0c\x20\x03(\x0e2\x18.efflux.CellActionStatusR\x0bcellActi\
    ons\">\n\x17InteractionLoginRequest\x12#\n\rsession_token\x18\x01\x20\
    \x01(\tR\x0csessionToken\"t\n\x18InteractionLoginResponse\x12#\n\rsessio\
    n_token\x18\x01\x20\x01(\tR\x0csessionToken\x12\x16\n\x06expiry\x18\x02\
    \x20\x01(\x05R\x06expiry\x12\x1b\n\trender_id\x18\x03\x20\x01(\tR\x08ren\
    derId\"\xf0\x01\n\x12InteractionRequest\x12#\n\rsession_token\x18\x01\
    \x20\x01(\tR\x0csessionToken\x12+\n\x04type\x18\x02\x20\x01(\x0e2\x17.ef\
    flux.InteractionTypeR\x04type\x12,\n\x08position\x18\x03\x20\x01(\x0b2\
    \x10.efflux.PositionR\x08position\x12\x1f\n\x0btarget_cell\x18\x04\x20\
    \x01(\tR\ntargetCell\x129\n\rcytokine_type\x18\x05\x20\x01(\x0e2\x14.eff\
    lux.CytokineTypeR\x0ccytokineType\"\xf0\x02\n\x13InteractionResponse\x12\
    +\n\x04type\x18\x01\x20\x01(\x0e2\x17.efflux.InteractionTypeR\x04type\
    \x12:\n\x06status\x18\x02\x20\x01(\x0e2\".efflux.InteractionResponse.Sta\
    tusR\x06status\x12#\n\rerror_message\x18\x03\x20\x01(\tR\x0cerrorMessage\
    \x12\x1f\n\x0battached_to\x18\x04\x20\x01(\tR\nattachedTo\x12@\n\x12targ\
    et_cell_status\x18\x05\x20\x01(\x0b2\x12.efflux.CellStatusR\x10targetCel\
    lStatus\x12D\n\x14attached_cell_status\x18\x06\x20\x01(\x0b2\x12.efflux.\
    CellStatusR\x12attachedCellStatus\"\"\n\x06Status\x12\x0b\n\x07failure\
    \x10\0\x12\x0b\n\x07success\x10\x01*\xb5\x03\n\x08CellType\x12\x0c\n\x08\
    Bacteria\x10\0\x12\x10\n\x0cBacteroidota\x10\x01\x12\x0c\n\x08RedBlood\
    \x10\x02\x12\n\n\x06Neuron\x10\x03\x12\x11\n\rCardiomyocyte\x10\x04\x12\
    \x0e\n\nPneumocyte\x10\x05\x12\x0b\n\x07Myocyte\x10\x06\x12\x10\n\x0cKer\
    atinocyte\x10\x07\x12\x0e\n\nEnterocyte\x10\x08\x12\x0c\n\x08Podocyte\
    \x10\t\x12\x11\n\rHemocytoblast\x10\n\x12\x0f\n\x0bLymphoblast\x10\x0b\
    \x12\x0e\n\nMyeloblast\x10\x0c\x12\x0c\n\x08Monocyte\x10\r\x12\x12\n\x0e\
    Macrophagocyte\x10\x0e\x12\r\n\tDendritic\x10\x0f\x12\x0e\n\nNeutrocyte\
    \x10\x10\x12\x15\n\x11NaturalKillerCell\x10\x11\x12\x15\n\x11VirginTLymp\
    hocyte\x10\x12\x12\x15\n\x11HelperTLymphocyte\x10\x13\x12\x15\n\x11Kille\
    rTLymphocyte\x10\x14\x12\x0f\n\x0bBLymphocyte\x10\x15\x12\x17\n\x13Effec\
    torBLymphocyte\x10\x16\x12\x14\n\x10ViralLoadCarrier\x10\x17*\x82\x01\n\
    \x08WorkType\x12\x0b\n\x07nothing\x10\0\x12\r\n\tdiffusion\x10\x01\x12\t\
    \n\x05cover\x10\x02\x12\x0c\n\x08exchange\x10\x03\x12\n\n\x06exhale\x10\
    \x04\x12\x08\n\x04pump\x10\x05\x12\x08\n\x04move\x10\x06\x12\t\n\x05thin\
    k\x10\x07\x12\n\n\x06digest\x10\x08\x12\n\n\x06filter\x10\t*{\n\x0cCytok\
    ineType\x12\x0b\n\x07unknown\x10\0\x12\x0f\n\x0bcell_damage\x10\x01\x12\
    \x11\n\rcell_stressed\x10\x02\x12\x13\n\x0fantigen_present\x10\x03\x12\
    \x15\n\x11induce_chemotaxis\x10\x04\x12\x0e\n\ncytotoxins\x10\x05*\x85\
    \x01\n\x10CellActionStatus\x12\x0e\n\ndo_nothing\x10\0\x12\n\n\x06repair\
    \x10\x01\x12\x10\n\x0cincur_damage\x10\x02\x12\x0b\n\x07despawn\x10\x03\
    \x12\r\n\tapoptosis\x10\x04\x12\x0b\n\x07do_work\x10\x05\x12\r\n\ttransp\
    ort\x10\x06\x12\x0b\n\x07mitosis\x10\x07*t\n\x0fInteractionType\x12\x08\
    \n\x04ping\x10\0\x12\t\n\x05close\x10\x01\x12\x0b\n\x07move_to\x10\x02\
    \x12\n\n\x06follow\x10\x03\x12\n\n\x06attach\x10\x04\x12\n\n\x06detach\
    \x10\x05\x12\x08\n\x04info\x10\x06\x12\x11\n\rdrop_cytokine\x10\x07B\x08\
    Z\x06./mainJ\xbeC\n\x07\x12\x05\0\0\xcd\x01\x01\n\x08\n\x01\x0c\x12\x03\
    \0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0f\n\x08\n\x01\x08\x12\x03\x03\0\
    \x1d\n\t\n\x02\x08\x0b\x12\x03\x03\0\x1d\n\n\n\x02\x05\0\x12\x04\x05\0\
    \x1e\x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\r\n+\n\x04\x05\0\x02\0\x12\
    \x03\x06\x04\x11\"\x1e\x20A\x20baseline\x20prokaryotic\x20cell.\n\n\x0c\
    \n\x05\x05\0\x02\0\x01\x12\x03\x06\x04\x0c\n\x0c\n\x05\x05\0\x02\0\x02\
    \x12\x03\x06\x0f\x10\n<\n\x04\x05\0\x02\x01\x12\x03\x07\x04\x15\"/\x20Ba\
    cteria\x20that\x20synthesize\x20vitamins\x20in\x20the\x20gut.\n\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03\x07\x04\x10\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\x07\x13\x14\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x04\x11\n\x0c\
    \n\x05\x05\0\x02\x02\x01\x12\x03\x08\x04\x0c\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03\x08\x0f\x10\n\x0b\n\x04\x05\0\x02\x03\x12\x03\t\x04\x0f\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x04\n\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\t\r\x0e\n\x19\n\x04\x05\0\x02\x04\x12\x03\n\x04\x16\"\x0c\
    \x20Heart\x20Cell\n\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x04\x11\n\
    \x0c\n\x05\x05\0\x02\x04\x02\x12\x03\n\x14\x15\n\x1d\n\x04\x05\0\x02\x05\
    \x12\x03\x0b\x04\x13\"\x10\x20Pulmonary\x20Cell\n\n\x0c\n\x05\x05\0\x02\
    \x05\x01\x12\x03\x0b\x04\x0e\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x0b\
    \x11\x12\n\x1a\n\x04\x05\0\x02\x06\x12\x03\x0c\x04\x10\"\r\x20Muscle\x20\
    Cell\n\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x04\x0b\n\x0c\n\x05\x05\
    \0\x02\x06\x02\x12\x03\x0c\x0e\x0f\n\x18\n\x04\x05\0\x02\x07\x12\x03\r\
    \x04\x15\"\x0b\x20Skin\x20Cell\n\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\
    \x04\x10\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\r\x13\x14\n\x1e\n\x04\x05\
    \0\x02\x08\x12\x03\x0e\x04\x13\"\x11\x20Gut\x20Lining\x20Cell\n\n\x0c\n\
    \x05\x05\0\x02\x08\x01\x12\x03\x0e\x04\x0e\n\x0c\n\x05\x05\0\x02\x08\x02\
    \x12\x03\x0e\x11\x12\n\x1a\n\x04\x05\0\x02\t\x12\x03\x0f\x04\x11\"\r\x20\
    Kidney\x20Cell\n\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0f\x04\x0c\n\x0c\n\
    \x05\x05\0\x02\t\x02\x12\x03\x0f\x0f\x10\nR\n\x04\x05\0\x02\n\x12\x03\
    \x10\x04\x17\"E\x20Bone\x20Marrow\x20Stem\x20Cell,\x20spawns\x20Lymphobl\
    ast,\x20Monocyte,\x20and\x20Myeloblast\n\n\x0c\n\x05\x05\0\x02\n\x01\x12\
    \x03\x10\x04\x11\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x10\x14\x16\n6\n\
    \x04\x05\0\x02\x0b\x12\x03\x11\x04\x15\")\x20Stem\x20Cell,\x20becomes\
    \x20NK,\x20B\x20cells,\x20T\x20cells\n\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\
    \x03\x11\x04\x0f\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x11\x12\x14\nX\n\
    \x04\x05\0\x02\x0c\x12\x03\x12\x04\x14\"K\x20Stem\x20Cell,\x20becomes\
    \x20Neutrophil\x20(also\x20Macrophages\x20and\x20Dendritic\x20cells\x20b\
    ut\x20n\n\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x12\x04\x0e\n\x0c\n\x05\
    \x05\0\x02\x0c\x02\x12\x03\x12\x11\x13\nA\n\x04\x05\0\x02\r\x12\x03\x13\
    \x04\x12\"4\x20Stem\x20Cell,\x20becomes\x20Macrophages\x20and\x20Dendrit\
    ic\x20cells\n\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\x04\x0c\n\x0c\n\
    \x05\x05\0\x02\r\x02\x12\x03\x13\x0f\x11\n\x19\n\x04\x05\0\x02\x0e\x12\
    \x03\x14\x04\x18\"\x0c\x20Macrophage\n\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\
    \x03\x14\x04\x12\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x14\x15\x17\n\x1e\
    \n\x04\x05\0\x02\x0f\x12\x03\x15\x04\x13\"\x11\x20Dendritic\x20Cells\n\n\
    \x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x04\r\n\x0c\n\x05\x05\0\x02\x0f\
    \x02\x12\x03\x15\x10\x12\n\x1a\n\x04\x05\0\x02\x10\x12\x03\x16\x04\x14\"\
    \r\x20Neutrophils\n\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x16\x04\x0e\n\
    \x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x16\x11\x13\n\"\n\x04\x05\0\x02\x11\
    \x12\x03\x17\x04\x1b\"\x15\x20Natural\x20Killer\x20Cell\n\n\x0c\n\x05\
    \x05\0\x02\x11\x01\x12\x03\x17\x04\x15\n\x0c\n\x05\x05\0\x02\x11\x02\x12\
    \x03\x17\x18\x1a\n\x1c\n\x04\x05\0\x02\x12\x12\x03\x18\x04\x1b\"\x0f\x20\
    Virgin\x20T\x20Cell\n\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x18\x04\x15\
    \n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x18\x18\x1a\n\x1c\n\x04\x05\0\x02\
    \x13\x12\x03\x19\x04\x1b\"\x0f\x20Helper\x20T\x20Cell\n\n\x0c\n\x05\x05\
    \0\x02\x13\x01\x12\x03\x19\x04\x15\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\
    \x19\x18\x1a\n\x1c\n\x04\x05\0\x02\x14\x12\x03\x1a\x04\x1b\"\x0f\x20Kill\
    er\x20T\x20Cell\n\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1a\x04\x15\n\
    \x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1a\x18\x1a\n\x15\n\x04\x05\0\x02\
    \x15\x12\x03\x1b\x04\x15\"\x08\x20B\x20Cell\n\n\x0c\n\x05\x05\0\x02\x15\
    \x01\x12\x03\x1b\x04\x0f\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1b\x12\
    \x14\n\x1a\n\x04\x05\0\x02\x16\x12\x03\x1c\x04\x1d\"\r\x20Plasma\x20Cell\
    \n\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1c\x04\x17\n\x0c\n\x05\x05\0\
    \x02\x16\x02\x12\x03\x1c\x1a\x1c\nP\n\x04\x05\0\x02\x17\x12\x03\x1d\x04\
    \x1a\"C\x20A\x20dummy\x20cell\x20that\x20carries\x20a\x20virus.\x20Alway\
    s\x20make\x20sure\x20this\x20is\x20last.\n\n\x0c\n\x05\x05\0\x02\x17\x01\
    \x12\x03\x1d\x04\x14\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1d\x17\x19\n\
    \n\n\x02\x05\x01\x12\x04\x20\0+\x01\n\n\n\x03\x05\x01\x01\x12\x03\x20\
    \x05\r\n\x0b\n\x04\x05\x01\x02\0\x12\x03!\x04\x10\n\x0c\n\x05\x05\x01\
    \x02\0\x01\x12\x03!\x04\x0b\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03!\x0e\
    \x0f\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\"\x08\x16\n\x0c\n\x05\x05\x01\
    \x02\x01\x01\x12\x03\"\x08\x11\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\"\
    \x14\x15\nS\n\x04\x05\x01\x02\x02\x12\x03#\x08\x12\"F\x20Called\x20on\
    \x20skin\x20cells\x20by\x20muscle\x20cells.\x20Will\x20randomly\x20fail,\
    \x20i.e.\x20cuts.\n\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03#\x08\r\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03#\x10\x11\n4\n\x04\x05\x01\x02\x03\x12\
    \x03$\x08\x15\"'\x20Called\x20on\x20blood\x20cells\x20by\x20other\x20cel\
    ls.\n\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03$\x08\x10\n\x0c\n\x05\x05\
    \x01\x02\x03\x02\x12\x03$\x13\x14\n3\n\x04\x05\x01\x02\x04\x12\x03%\x08\
    \x13\"&\x20Called\x20on\x20lung\x20cells\x20by\x20blood\x20cells.\n\n\
    \x0c\n\x05\x05\x01\x02\x04\x01\x12\x03%\x08\x0e\n\x0c\n\x05\x05\x01\x02\
    \x04\x02\x12\x03%\x11\x12\n?\n\x04\x05\x01\x02\x05\x12\x03&\x08\x11\"2\
    \x20Called\x20on\x20to\x20heart\x20cells\x20to\x20pump,\x20by\x20brain\
    \x20cels.\n\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03&\x08\x0c\n\x0c\n\x05\
    \x05\x01\x02\x05\x02\x12\x03&\x0f\x10\n5\n\x04\x05\x01\x02\x06\x12\x03'\
    \x08\x11\"(\x20Called\x20on\x20muscle\x20cells\x20by\x20brain\x20cells.\
    \n\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03'\x08\x0c\n\x0c\n\x05\x05\x01\
    \x02\x06\x02\x12\x03'\x0f\x10\nO\n\x04\x05\x01\x02\x07\x12\x03(\x08\x12\
    \"B\x20Called\x20on\x20brain\x20cells\x20to\x20perform\x20a\x20computati\
    on,\x20by\x20muscle\x20cells.\n\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03(\
    \x08\r\n\x0c\n\x05\x05\x01\x02\x07\x02\x12\x03(\x10\x11\n4\n\x04\x05\x01\
    \x02\x08\x12\x03)\x08\x13\"'\x20Called\x20on\x20gut\x20cells,\x20by\x20m\
    uscle\x20cells.\n\n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03)\x08\x0e\n\x0c\
    \n\x05\x05\x01\x02\x08\x02\x12\x03)\x11\x12\n6\n\x04\x05\x01\x02\t\x12\
    \x03*\x08\x13\")\x20Called\x20on\x20kidney\x20cells,\x20by\x20blood\x20c\
    ells.\n\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03*\x08\x0e\n\x0c\n\x05\x05\
    \x01\x02\t\x02\x12\x03*\x11\x12\n\n\n\x02\x04\0\x12\x04-\02\x01\n\n\n\
    \x03\x04\0\x01\x12\x03-\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03.\x08\x1c\
    \n\x0c\n\x05\x04\0\x02\0\x05\x12\x03.\x08\r\n\x0c\n\x05\x04\0\x02\0\x01\
    \x12\x03.\x0e\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03.\x1a\x1b\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03/\x08\x1a\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03/\x08\x0e\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03/\x0f\x15\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03/\x18\x19\n\x0b\n\x04\x04\0\x02\x02\x12\x030\
    \x08\x19\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x030\x08\r\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x030\x0e\x14\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x030\x17\
    \x18\n\x0b\n\x04\x04\0\x02\x03\x12\x031\x04&\n\x0c\n\x05\x04\0\x02\x03\
    \x06\x12\x031\x04\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x031\x18!\n\x0c\
    \n\x05\x04\0\x02\x03\x03\x12\x031$%\n\n\n\x02\x04\x01\x12\x043\07\x01\n\
    \n\n\x03\x04\x01\x01\x12\x033\x08\x1e\n\x0b\n\x04\x04\x01\x02\0\x12\x034\
    \x04\x11\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x034\x04\t\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x034\n\x0c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x034\x0f\
    \x10\n\x0b\n\x04\x04\x01\x02\x01\x12\x035\x04\x16\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x035\x04\t\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x035\n\
    \x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x035\x14\x15\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x036\x04\x17\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x036\
    \x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x036\n\x12\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x036\x15\x16\n\n\n\x02\x04\x02\x12\x049\0<\x01\n\n\
    \n\x03\x04\x02\x01\x12\x039\x08\x1b\n\x0b\n\x04\x04\x02\x02\0\x12\x03:\
    \x04\x13\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03:\x04\t\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03:\n\x0e\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03:\x11\
    \x12\n\x0b\n\x04\x04\x02\x02\x01\x12\x03;\x04\x19\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x03;\x04\t\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03;\n\
    \x14\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x17\x18\n\n\n\x02\x04\x03\
    \x12\x04>\0C\x01\n\n\n\x03\x04\x03\x01\x12\x03>\x08\x1d\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03?\x044\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03?\x04\t\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03?\n/\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03?23\n\x0b\n\x04\x04\x03\x02\x01\x12\x03@\x043\n\x0c\n\x05\x04\
    \x03\x02\x01\x05\x12\x03@\x04\t\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03@\
    \n.\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03@12\n\x0b\n\x04\x04\x03\x02\
    \x02\x12\x03A\x04\x1b\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03A\x04\t\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x03A\n\x16\n\x0c\n\x05\x04\x03\x02\
    \x02\x03\x12\x03A\x19\x1a\n\x0b\n\x04\x04\x03\x02\x03\x12\x03B\x04\x1b\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03B\x04\t\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03B\n\x16\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03B\x19\x1a\
    \n\n\n\x02\x04\x04\x12\x04E\0H\x01\n\n\n\x03\x04\x04\x01\x12\x03E\x08\
    \x1d\n\x0b\n\x04\x04\x04\x02\0\x12\x03F\x04)\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x03F\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03F\r\x12\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x03F\x13$\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03F'(\n\x0b\n\x04\x04\x04\x02\x01\x12\x03G\x04/\n\x0c\n\x05\x04\x04\
    \x02\x01\x04\x12\x03G\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03G\r\
    \x12\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03G\x13*\n\x0c\n\x05\x04\x04\
    \x02\x01\x03\x12\x03G-.\n\n\n\x02\x04\x05\x12\x04J\0O\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03J\x08\x1b\n\x0b\n\x04\x04\x05\x02\0\x12\x03K\x08-\n\x0c\
    \n\x05\x04\x05\x02\0\x06\x12\x03K\x08\x1e\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03K\x1f(\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03K+,\n\x0b\n\x04\x04\
    \x05\x02\x01\x12\x03L\x08&\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03L\x08\
    \x1b\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03L\x1c!\n\x0c\n\x05\x04\x05\
    \x02\x01\x03\x12\x03L$%\n\x0b\n\x04\x04\x05\x02\x02\x12\x03M\x08*\n\x0c\
    \n\x05\x04\x05\x02\x02\x06\x12\x03M\x08\x1d\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03M\x1e%\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03M()\n\x0b\n\
    \x04\x04\x05\x02\x03\x12\x03N\x08*\n\x0c\n\x05\x04\x05\x02\x03\x06\x12\
    \x03N\x08\x1d\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03N\x1e%\n\x0c\n\x05\
    \x04\x05\x02\x03\x03\x12\x03N()\n\n\n\x02\x04\x06\x12\x04Q\0X\x01\n\n\n\
    \x03\x04\x06\x01\x12\x03Q\x08\x1c\n\x0b\n\x04\x04\x06\x02\0\x12\x03R\x04\
    \x19\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03R\x04\n\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03R\x0b\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03R\x17\
    \x18\n\x0b\n\x04\x04\x06\x02\x01\x12\x03S\x04\x1c\n\x0c\n\x05\x04\x06\
    \x02\x01\x05\x12\x03S\x04\t\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03S\n\
    \x17\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03S\x1a\x1b\n\x0b\n\x04\x04\
    \x06\x02\x02\x12\x03T\x04\x1c\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03T\
    \x04\t\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03T\n\x17\n\x0c\n\x05\x04\
    \x06\x02\x02\x03\x12\x03T\x1a\x1b\n\x0b\n\x04\x04\x06\x02\x03\x12\x03U\
    \x04\x1c\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03U\x04\t\n\x0c\n\x05\x04\
    \x06\x02\x03\x01\x12\x03U\n\x17\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03U\
    \x1a\x1b\n\x0b\n\x04\x04\x06\x02\x04\x12\x03V\x04\x1e\n\x0c\n\x05\x04\
    \x06\x02\x04\x05\x12\x03V\x04\t\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03V\
    \n\x19\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03V\x1c\x1d\n\x0b\n\x04\x04\
    \x06\x02\x05\x12\x03W\x04&\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03W\x04\
    \t\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03W\n!\n\x0c\n\x05\x04\x06\x02\
    \x05\x03\x12\x03W$%\n\n\n\x02\x04\x07\x12\x04Z\0j\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03Z\x08\x20\n\x0b\n\x04\x04\x07\x02\0\x12\x03[\x04\x11\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03[\x04\t\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03[\n\x0c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03[\x0f\x10\n\x0b\n\x04\
    \x04\x07\x02\x01\x12\x03\\\x04\x16\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\
    \x03\\\x04\t\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03\\\n\x11\n\x0c\n\x05\
    \x04\x07\x02\x01\x03\x12\x03\\\x14\x15\n\x0b\n\x04\x04\x07\x02\x02\x12\
    \x03]\x04\x16\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03]\x04\t\n\x0c\n\x05\
    \x04\x07\x02\x02\x01\x12\x03]\n\x11\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03]\x14\x15\n\x0b\n\x04\x04\x07\x02\x03\x12\x03^\x04\x12\n\x0c\n\x05\
    \x04\x07\x02\x03\x05\x12\x03^\x04\t\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\
    \x03^\n\r\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03^\x10\x11\n\x0b\n\x04\
    \x04\x07\x02\x04\x12\x03_\x04\x19\n\x0c\n\x05\x04\x07\x02\x04\x05\x12\
    \x03_\x04\t\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03_\n\x14\n\x0c\n\x05\
    \x04\x07\x02\x04\x03\x12\x03_\x17\x18\n\x0b\n\x04\x04\x07\x02\x05\x12\
    \x03`\x04\x15\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03`\x04\t\n\x0c\n\x05\
    \x04\x07\x02\x05\x01\x12\x03`\n\x10\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\
    \x03`\x13\x14\n\x0b\n\x04\x04\x07\x02\x06\x12\x03a\x04\x15\n\x0c\n\x05\
    \x04\x07\x02\x06\x05\x12\x03a\x04\t\n\x0c\n\x05\x04\x07\x02\x06\x01\x12\
    \x03a\n\x10\n\x0c\n\x05\x04\x07\x02\x06\x03\x12\x03a\x13\x14\n\x0b\n\x04\
    \x04\x07\x02\x07\x12\x03b\x04\x17\n\x0c\n\x05\x04\x07\x02\x07\x05\x12\
    \x03b\x04\t\n\x0c\n\x05\x04\x07\x02\x07\x01\x12\x03b\n\x12\n\x0c\n\x05\
    \x04\x07\x02\x07\x03\x12\x03b\x15\x16\n\x0b\n\x04\x04\x07\x02\x08\x12\
    \x03c\x04\x1b\n\x0c\n\x05\x04\x07\x02\x08\x05\x12\x03c\x04\t\n\x0c\n\x05\
    \x04\x07\x02\x08\x01\x12\x03c\n\x16\n\x0c\n\x05\x04\x07\x02\x08\x03\x12\
    \x03c\x19\x1a\n\x0b\n\x04\x04\x07\x02\t\x12\x03d\x04\x15\n\x0c\n\x05\x04\
    \x07\x02\t\x05\x12\x03d\x04\t\n\x0c\n\x05\x04\x07\x02\t\x01\x12\x03d\n\
    \x0f\n\x0c\n\x05\x04\x07\x02\t\x03\x12\x03d\x12\x14\n\x0b\n\x04\x04\x07\
    \x02\n\x12\x03e\x04\x15\n\x0c\n\x05\x04\x07\x02\n\x05\x12\x03e\x04\t\n\
    \x0c\n\x05\x04\x07\x02\n\x01\x12\x03e\n\x0f\n\x0c\n\x05\x04\x07\x02\n\
    \x03\x12\x03e\x12\x14\n\x0b\n\x04\x04\x07\x02\x0b\x12\x03f\x04\x14\n\x0c\
    \n\x05\x04\x07\x02\x0b\x05\x12\x03f\x04\t\n\x0c\n\x05\x04\x07\x02\x0b\
    \x01\x12\x03f\n\x0e\n\x0c\n\x05\x04\x07\x02\x0b\x03\x12\x03f\x11\x13\n\
    \x0b\n\x04\x04\x07\x02\x0c\x12\x03g\x04\x14\n\x0c\n\x05\x04\x07\x02\x0c\
    \x05\x12\x03g\x04\t\n\x0c\n\x05\x04\x07\x02\x0c\x01\x12\x03g\n\x0e\n\x0c\
    \n\x05\x04\x07\x02\x0c\x03\x12\x03g\x11\x13\n\x0b\n\x04\x04\x07\x02\r\
    \x12\x03h\x04\x1a\n\x0c\n\x05\x04\x07\x02\r\x05\x12\x03h\x04\t\n\x0c\n\
    \x05\x04\x07\x02\r\x01\x12\x03h\n\x14\n\x0c\n\x05\x04\x07\x02\r\x03\x12\
    \x03h\x17\x19\n\x0b\n\x04\x04\x07\x02\x0e\x12\x03i\x04\x1d\n\x0c\n\x05\
    \x04\x07\x02\x0e\x05\x12\x03i\x04\t\n\x0c\n\x05\x04\x07\x02\x0e\x01\x12\
    \x03i\n\x17\n\x0c\n\x05\x04\x07\x02\x0e\x03\x12\x03i\x1a\x1c\n\n\n\x02\
    \x05\x02\x12\x04l\0s\x01\n\n\n\x03\x05\x02\x01\x12\x03l\x05\x11\n\x0b\n\
    \x04\x05\x02\x02\0\x12\x03m\x04\x10\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03m\x04\x0b\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03m\x0e\x0f\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03n\x08\x18\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\
    \x03n\x08\x13\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03n\x16\x17\n\x0b\n\
    \x04\x05\x02\x02\x02\x12\x03o\x08\x1a\n\x0c\n\x05\x05\x02\x02\x02\x01\
    \x12\x03o\x08\x15\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03o\x18\x19\n\x0b\
    \n\x04\x05\x02\x02\x03\x12\x03p\x08\x1c\n\x0c\n\x05\x05\x02\x02\x03\x01\
    \x12\x03p\x08\x17\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03p\x1a\x1b\n\x0b\
    \n\x04\x05\x02\x02\x04\x12\x03q\x08\x1e\n\x0c\n\x05\x05\x02\x02\x04\x01\
    \x12\x03q\x08\x19\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03q\x1c\x1d\n\x0b\
    \n\x04\x05\x02\x02\x05\x12\x03r\x08\x17\n\x0c\n\x05\x05\x02\x02\x05\x01\
    \x12\x03r\x08\x12\n\x0c\n\x05\x05\x02\x02\x05\x02\x12\x03r\x15\x16\n\n\n\
    \x02\x04\x08\x12\x04u\0|\x01\n\n\n\x03\x04\x08\x01\x12\x03u\x08\x18\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03v\x08\x19\n\x0c\n\x05\x04\x08\x02\0\x05\
    \x12\x03v\x08\r\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03v\x0e\x14\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x03v\x17\x18\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03w\x08\x18\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03w\x08\x0e\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03w\x0f\x13\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03w\x16\x17\n\x0b\n\x04\x04\x08\x02\x02\x12\x03x\x08(\n\x0c\n\
    \x05\x04\x08\x02\x02\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\
    \x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03x\x18#\n\
    \x0c\n\x05\x04\x08\x02\x02\x03\x12\x03x&'\n\x0b\n\x04\x04\x08\x02\x03\
    \x12\x03y\x086\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\x03y\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\x03\x06\x12\x03y\x11%\n\x0c\n\x05\x04\x08\x02\x03\x01\
    \x12\x03y&1\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03y45\n\x0b\n\x04\x04\
    \x08\x02\x04\x12\x03z\x085\n\x0c\n\x05\x04\x08\x02\x04\x06\x12\x03z\x08\
    \x20\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03z!0\n\x0c\n\x05\x04\x08\x02\
    \x04\x03\x12\x03z34\n\x0b\n\x02\x04\t\x12\x05~\0\x82\x01\x01\n\n\n\x03\
    \x04\t\x01\x12\x03~\x08\x1c\n\x0b\n\x04\x04\t\x02\0\x12\x03\x7f\x04\x12\
    \n\x0c\n\x05\x04\t\x02\0\x05\x12\x03\x7f\x04\n\n\x0c\n\x05\x04\t\x02\0\
    \x01\x12\x03\x7f\x0b\r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03\x7f\x10\x11\n\
    \x0c\n\x04\x04\t\x02\x01\x12\x04\x80\x01\x08\x19\n\r\n\x05\x04\t\x02\x01\
    \x05\x12\x04\x80\x01\x08\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x80\x01\
    \r\x14\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x80\x01\x17\x18\n\x0c\n\x04\
    \x04\t\x02\x02\x12\x04\x81\x01\x08\x1e\n\r\n\x05\x04\t\x02\x02\x06\x12\
    \x04\x81\x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x81\x01\x11\x19\
    \n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x81\x01\x1c\x1d\n\x0c\n\x02\x04\n\
    \x12\x06\x84\x01\0\x88\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x84\x01\x08\
    \x10\n\x0c\n\x04\x04\n\x02\0\x12\x04\x85\x01\x04\x10\n\r\n\x05\x04\n\x02\
    \0\x05\x12\x04\x85\x01\x04\t\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x85\x01\n\
    \x0b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x85\x01\x0e\x0f\n\x0c\n\x04\x04\n\
    \x02\x01\x12\x04\x86\x01\x04\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x86\
    \x01\x04\t\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x86\x01\n\x0b\n\r\n\x05\
    \x04\n\x02\x01\x03\x12\x04\x86\x01\x0e\x0f\n\x0c\n\x04\x04\n\x02\x02\x12\
    \x04\x87\x01\x04\x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x87\x01\x04\t\n\
    \r\n\x05\x04\n\x02\x02\x01\x12\x04\x87\x01\n\x0b\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\x87\x01\x0e\x0f\n\x0c\n\x02\x05\x03\x12\x06\x8a\x01\0\x93\
    \x01\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\x8a\x01\x05\x15\n\x0c\n\x04\x05\
    \x03\x02\0\x12\x04\x8b\x01\x04\x13\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\
    \x8b\x01\x04\x0e\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\x8b\x01\x11\x12\n\
    \x0c\n\x04\x05\x03\x02\x01\x12\x04\x8c\x01\x04\x0f\n\r\n\x05\x05\x03\x02\
    \x01\x01\x12\x04\x8c\x01\x04\n\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\x8c\
    \x01\r\x0e\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\x8d\x01\x04\x15\n\r\n\x05\
    \x05\x03\x02\x02\x01\x12\x04\x8d\x01\x04\x10\n\r\n\x05\x05\x03\x02\x02\
    \x02\x12\x04\x8d\x01\x13\x14\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\x8e\x01\
    \x04\x10\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\x8e\x01\x04\x0b\n\r\n\x05\
    \x05\x03\x02\x03\x02\x12\x04\x8e\x01\x0e\x0f\n\x0c\n\x04\x05\x03\x02\x04\
    \x12\x04\x8f\x01\x04\x12\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\x8f\x01\
    \x04\r\n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\x8f\x01\x10\x11\n\x0c\n\x04\
    \x05\x03\x02\x05\x12\x04\x90\x01\x04\x10\n\r\n\x05\x05\x03\x02\x05\x01\
    \x12\x04\x90\x01\x04\x0b\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\x90\x01\
    \x0e\x0f\n\x0c\n\x04\x05\x03\x02\x06\x12\x04\x91\x01\x04\x12\n\r\n\x05\
    \x05\x03\x02\x06\x01\x12\x04\x91\x01\x04\r\n\r\n\x05\x05\x03\x02\x06\x02\
    \x12\x04\x91\x01\x10\x11\n\x0c\n\x04\x05\x03\x02\x07\x12\x04\x92\x01\x04\
    \x10\n\r\n\x05\x05\x03\x02\x07\x01\x12\x04\x92\x01\x04\x0b\n\r\n\x05\x05\
    \x03\x02\x07\x02\x12\x04\x92\x01\x0e\x0f\n\x0c\n\x02\x04\x0b\x12\x06\x95\
    \x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x95\x01\x08\x12\n\x0c\
    \n\x04\x04\x0b\x02\0\x12\x04\x96\x01\x04\x18\n\r\n\x05\x04\x0b\x02\0\x05\
    \x12\x04\x96\x01\x04\t\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x96\x01\n\x13\
    \n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x96\x01\x16\x17\n\x0c\n\x04\x04\x0b\
    \x02\x01\x12\x04\x97\x01\x04\x1b\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\
    \x97\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x97\x01\r\x16\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\x97\x01\x19\x1a\n\x0c\n\x04\x04\x0b\
    \x02\x02\x12\x04\x98\x01\x04\x14\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\
    \x98\x01\x04\n\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x98\x01\x0b\x0f\n\r\
    \n\x05\x04\x0b\x02\x02\x03\x12\x04\x98\x01\x12\x13\n\x0c\n\x04\x04\x0b\
    \x02\x03\x12\x04\x99\x01\x04\x19\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\
    \x99\x01\x04\n\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x99\x01\x0b\x14\n\r\
    \n\x05\x04\x0b\x02\x03\x03\x12\x04\x99\x01\x17\x18\n\x0c\n\x04\x04\x0b\
    \x02\x04\x12\x04\x9a\x01\x04\x15\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\
    \x9a\x01\x04\t\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x9a\x01\n\x10\n\r\n\
    \x05\x04\x0b\x02\x04\x03\x12\x04\x9a\x01\x13\x14\n\x0c\n\x04\x04\x0b\x02\
    \x05\x12\x04\x9b\x01\x04\x19\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x9b\
    \x01\x04\t\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x9b\x01\n\x14\n\r\n\x05\
    \x04\x0b\x02\x05\x03\x12\x04\x9b\x01\x17\x18\n\x0c\n\x04\x04\x0b\x02\x06\
    \x12\x04\x9c\x01\x04\x19\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\x9c\x01\
    \x04\t\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\x9c\x01\n\x14\n\r\n\x05\x04\
    \x0b\x02\x06\x03\x12\x04\x9c\x01\x17\x18\n\x0c\n\x04\x04\x0b\x02\x07\x12\
    \x04\x9d\x01\x04'\n\r\n\x05\x04\x0b\x02\x07\x04\x12\x04\x9d\x01\x04\x0c\
    \n\r\n\x05\x04\x0b\x02\x07\x05\x12\x04\x9d\x01\r\x13\n\r\n\x05\x04\x0b\
    \x02\x07\x01\x12\x04\x9d\x01\x14\"\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\
    \x9d\x01%&\n\x0c\n\x04\x04\x0b\x02\x08\x12\x04\x9e\x01\x04\"\n\r\n\x05\
    \x04\x0b\x02\x08\x04\x12\x04\x9e\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x08\
    \x05\x12\x04\x9e\x01\r\x13\n\r\n\x05\x04\x0b\x02\x08\x01\x12\x04\x9e\x01\
    \x14\x1d\n\r\n\x05\x04\x0b\x02\x08\x03\x12\x04\x9e\x01\x20!\n\x0c\n\x04\
    \x04\x0b\x02\t\x12\x04\x9f\x01\x04\"\n\r\n\x05\x04\x0b\x02\t\x04\x12\x04\
    \x9f\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\t\x05\x12\x04\x9f\x01\r\x13\n\r\n\
    \x05\x04\x0b\x02\t\x01\x12\x04\x9f\x01\x14\x1c\n\r\n\x05\x04\x0b\x02\t\
    \x03\x12\x04\x9f\x01\x1f!\n\x0c\n\x04\x04\x0b\x02\n\x12\x04\xa0\x01\x04#\
    \n\r\n\x05\x04\x0b\x02\n\x04\x12\x04\xa0\x01\x04\x0c\n\r\n\x05\x04\x0b\
    \x02\n\x05\x12\x04\xa0\x01\r\x13\n\r\n\x05\x04\x0b\x02\n\x01\x12\x04\xa0\
    \x01\x14\x1d\n\r\n\x05\x04\x0b\x02\n\x03\x12\x04\xa0\x01\x20\"\n\x0c\n\
    \x04\x04\x0b\x02\x0b\x12\x04\xa1\x01\x040\n\r\n\x05\x04\x0b\x02\x0b\x04\
    \x12\x04\xa1\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x0b\x06\x12\x04\xa1\x01\r\
    \x1d\n\r\n\x05\x04\x0b\x02\x0b\x01\x12\x04\xa1\x01\x1e*\n\r\n\x05\x04\
    \x0b\x02\x0b\x03\x12\x04\xa1\x01-/\n\x0c\n\x02\x04\x0c\x12\x06\xa4\x01\0\
    \xa6\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa4\x01\x08\x1f\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\xa5\x01\x04\x1d\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xa5\x01\x04\n\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa5\x01\x0b\x18\n\
    \r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa5\x01\x1b\x1c\n\x0c\n\x02\x04\r\x12\
    \x06\xa8\x01\0\xac\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xa8\x01\x08\x20\
    \n\x0c\n\x04\x04\r\x02\0\x12\x04\xa9\x01\x04\x1d\n\r\n\x05\x04\r\x02\0\
    \x05\x12\x04\xa9\x01\x04\n\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa9\x01\x0b\
    \x18\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa9\x01\x1b\x1c\n\x0c\n\x04\x04\r\
    \x02\x01\x12\x04\xaa\x01\x04\x15\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xaa\
    \x01\x04\t\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xaa\x01\n\x10\n\r\n\x05\
    \x04\r\x02\x01\x03\x12\x04\xaa\x01\x13\x14\n\x0c\n\x04\x04\r\x02\x02\x12\
    \x04\xab\x01\x04\x19\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xab\x01\x04\n\n\
    \r\n\x05\x04\r\x02\x02\x01\x12\x04\xab\x01\x0b\x14\n\r\n\x05\x04\r\x02\
    \x02\x03\x12\x04\xab\x01\x17\x18\n\x0c\n\x02\x05\x04\x12\x06\xae\x01\0\
    \xb7\x01\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xae\x01\x05\x14\n\x0c\n\x04\
    \x05\x04\x02\0\x12\x04\xaf\x01\x04\r\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\
    \xaf\x01\x04\x08\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xaf\x01\x0b\x0c\n\
    \x0c\n\x04\x05\x04\x02\x01\x12\x04\xb0\x01\x04\x0e\n\r\n\x05\x05\x04\x02\
    \x01\x01\x12\x04\xb0\x01\x04\t\n\r\n\x05\x05\x04\x02\x01\x02\x12\x04\xb0\
    \x01\x0c\r\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xb1\x01\x04\x10\n\r\n\x05\
    \x05\x04\x02\x02\x01\x12\x04\xb1\x01\x04\x0b\n\r\n\x05\x05\x04\x02\x02\
    \x02\x12\x04\xb1\x01\x0e\x0f\n\x0c\n\x04\x05\x04\x02\x03\x12\x04\xb2\x01\
    \x04\x0f\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xb2\x01\x04\n\n\r\n\x05\
    \x05\x04\x02\x03\x02\x12\x04\xb2\x01\r\x0e\n\x0c\n\x04\x05\x04\x02\x04\
    \x12\x04\xb3\x01\x04\x0f\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xb3\x01\
    \x04\n\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xb3\x01\r\x0e\n\x0c\n\x04\
    \x05\x04\x02\x05\x12\x04\xb4\x01\x04\x0f\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\xb4\x01\x04\n\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xb4\x01\r\
    \x0e\n\x0c\n\x04\x05\x04\x02\x06\x12\x04\xb5\x01\x04\r\n\r\n\x05\x05\x04\
    \x02\x06\x01\x12\x04\xb5\x01\x04\x08\n\r\n\x05\x05\x04\x02\x06\x02\x12\
    \x04\xb5\x01\x0b\x0c\n\x0c\n\x04\x05\x04\x02\x07\x12\x04\xb6\x01\x04\x16\
    \n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\xb6\x01\x04\x11\n\r\n\x05\x05\x04\
    \x02\x07\x02\x12\x04\xb6\x01\x14\x15\n\x0c\n\x02\x04\x0e\x12\x06\xb9\x01\
    \0\xbf\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xb9\x01\x08\x1a\n\x0c\n\
    \x04\x04\x0e\x02\0\x12\x04\xba\x01\x04\x1d\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\xba\x01\x04\n\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xba\x01\x0b\
    \x18\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xba\x01\x1b\x1c\n\x0c\n\x04\x04\
    \x0e\x02\x01\x12\x04\xbb\x01\x04\x1d\n\r\n\x05\x04\x0e\x02\x01\x06\x12\
    \x04\xbb\x01\x04\x13\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xbb\x01\x14\
    \x18\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xbb\x01\x1b\x1c\n\x0c\n\x04\
    \x04\x0e\x02\x02\x12\x04\xbc\x01\x04\x1a\n\r\n\x05\x04\x0e\x02\x02\x06\
    \x12\x04\xbc\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xbc\x01\r\
    \x15\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xbc\x01\x18\x19\n\x0c\n\x04\
    \x04\x0e\x02\x03\x12\x04\xbd\x01\x04\x1b\n\r\n\x05\x04\x0e\x02\x03\x05\
    \x12\x04\xbd\x01\x04\n\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xbd\x01\x0b\
    \x16\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xbd\x01\x19\x1a\n\x0c\n\x04\
    \x04\x0e\x02\x04\x12\x04\xbe\x01\x04#\n\r\n\x05\x04\x0e\x02\x04\x06\x12\
    \x04\xbe\x01\x04\x10\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xbe\x01\x11\
    \x1e\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xbe\x01!\"\n\x0c\n\x02\x04\
    \x0f\x12\x06\xc1\x01\0\xcd\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xc1\
    \x01\x08\x1b\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xc2\x01\x04\x1d\n\r\n\x05\
    \x04\x0f\x02\0\x06\x12\x04\xc2\x01\x04\x13\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xc2\x01\x14\x18\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc2\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xc3\x01\x04\x16\n\r\n\x05\x04\
    \x0f\x02\x01\x06\x12\x04\xc3\x01\x04\n\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\xc3\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xc3\x01\x14\
    \x15\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xc4\x01\x04\x1d\n\r\n\x05\x04\
    \x0f\x02\x02\x05\x12\x04\xc4\x01\x04\n\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\xc4\x01\x0b\x18\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xc4\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xc5\x01\x04\x1b\n\r\n\x05\x04\
    \x0f\x02\x03\x05\x12\x04\xc5\x01\x04\n\n\r\n\x05\x04\x0f\x02\x03\x01\x12\
    \x04\xc5\x01\x0b\x16\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xc5\x01\x19\
    \x1a\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\xc6\x01\x04&\n\r\n\x05\x04\x0f\
    \x02\x04\x06\x12\x04\xc6\x01\x04\x0e\n\r\n\x05\x04\x0f\x02\x04\x01\x12\
    \x04\xc6\x01\x0f!\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xc6\x01$%\n\x0c\
    \n\x04\x04\x0f\x02\x05\x12\x04\xc7\x01\x04(\n\r\n\x05\x04\x0f\x02\x05\
    \x06\x12\x04\xc7\x01\x04\x0e\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xc7\
    \x01\x0f#\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xc7\x01&'\n\x0e\n\x04\
    \x04\x0f\x04\0\x12\x06\xc9\x01\x04\xcc\x01\x05\n\r\n\x05\x04\x0f\x04\0\
    \x01\x12\x04\xc9\x01\t\x0f\n\x0e\n\x06\x04\x0f\x04\0\x02\0\x12\x04\xca\
    \x01\x08\x14\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x01\x12\x04\xca\x01\x08\x0f\
    \n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\xca\x01\x12\x13\n\x0e\n\x06\
    \x04\x0f\x04\0\x02\x01\x12\x04\xcb\x01\x08\x14\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x01\x01\x12\x04\xcb\x01\x08\x0f\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\
    \x02\x12\x04\xcb\x01\x12\x13b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(WorkSocketData::generated_message_descriptor_data());
            messages.push(ResourceBlobSocketData::generated_message_descriptor_data());
            messages.push(WasteBlobSocketData::generated_message_descriptor_data());
            messages.push(HormoneBlobSocketData::generated_message_descriptor_data());
            messages.push(AntigenBlobSocketData::generated_message_descriptor_data());
            messages.push(DiffusionSocketData::generated_message_descriptor_data());
            messages.push(WorkStatusSocketData::generated_message_descriptor_data());
            messages.push(MaterialStatusSocketData::generated_message_descriptor_data());
            messages.push(StatusSocketData::generated_message_descriptor_data());
            messages.push(RenderableSocketData::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(CellStatus::generated_message_descriptor_data());
            messages.push(InteractionLoginRequest::generated_message_descriptor_data());
            messages.push(InteractionLoginResponse::generated_message_descriptor_data());
            messages.push(InteractionRequest::generated_message_descriptor_data());
            messages.push(InteractionResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(CellType::generated_enum_descriptor_data());
            enums.push(WorkType::generated_enum_descriptor_data());
            enums.push(CytokineType::generated_enum_descriptor_data());
            enums.push(CellActionStatus::generated_enum_descriptor_data());
            enums.push(InteractionType::generated_enum_descriptor_data());
            enums.push(interaction_response::Status::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
